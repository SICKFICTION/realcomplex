<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes" />
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Complex Function Visualizer</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            background: #111;
            color: #eee;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            overflow: hidden;
            transition: background-color 0.3s, color 0.3s;
            /* Prevent zoom on double-tap */
            touch-action: manipulation;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            -ms-touch-action: manipulation;
        }

        /* Light mode styles */
        body.light-mode {
            background: #f5f5f5;
            color: #222;
        }

        body.light-mode canvas {
            background: #ffffff !important;
        }

        body.light-mode .domain {
            border-right: 2px solid #ccc;
        }

        body.light-mode .codomain {
            border-left: 2px solid #ccc;
        }

        body.light-mode #controls {
            background: rgba(255, 255, 255, 0.9);
            color: #222;
            border: 1px solid #ccc;
        }

        body.light-mode .canvas-label {
            color: #555;
        }

        body.light-mode .help-btn {
            background: rgba(200, 50, 50, 0.9);
        }

        body.light-mode .export-btn {
            background: rgba(50, 150, 50, 0.9);
        }

        body.light-mode .direction-btn {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #333;
            color: #333;
        }

        body.light-mode .direction-btn:hover {
            background: rgba(255, 255, 255, 1);
        }

        body.light-mode .direction-btn.center {
            background: rgba(70, 130, 180, 0.9);
        }

        body.light-mode .direction-btn.center:hover {
            background: rgba(70, 130, 180, 1);
        }

        body.light-mode .hover-tooltip {
            background: rgba(255, 255, 255, 0.95);
            color: #2c5282;
            border: 1px solid #2c5282;
        }

        #themeToggle {
            transition: all 0.3s;
        }

        #themeToggle:hover {
            transform: scale(1.1);
        }

        #controls {
            width: 100%;
            background: rgba(0, 0, 0, 0.8);
            padding: 4px 8px;
            z-index: 10;
            display: flex;
            gap: 4px;
            align-items: center;
            justify-content: space-evenly;
            flex-wrap: nowrap;
            border-bottom: 1px solid #444;
            position: relative;
            min-height: 40px;
            overflow-x: auto;
            /* Hide scrollbars but allow scrolling */
            scrollbar-width: none;
            /* Firefox */
            -ms-overflow-style: none;
            /* IE/Edge */
        }

        #controls::-webkit-scrollbar {
            display: none;
            /* Chrome/Safari */
        }

        #controls label {
            font-size: 11px;
            white-space: nowrap;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            gap: 2px;
        }

        #controls select,
        #controls input,
        #controls button {
            font-size: 11px;
            padding: 2px 4px;
            min-height: 24px;
            border-radius: 3px;
            border: none;
            touch-action: manipulation;
            flex-shrink: 0;
        }

        /* Mobile responsive adjustments for controls */
        @media (max-width: 768px) {
            html {
                overflow-y: auto;
                /* Ensure html can scroll vertically */
                height: 100%;
            }

            body {
                margin: 0;
                padding: 0;
                overflow-x: hidden;
                overflow-y: auto;
                /* Allow vertical scrolling on mobile */
                height: 100%;
                /* Remove body padding-bottom as it pushes content down */
            }

            #controls {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                padding: 8px 5px;
                margin: 0;
                background: rgba(40, 40, 40, 0.95);
                backdrop-filter: blur(10px);
                flex-wrap: wrap;
                gap: 4px;
                z-index: 1000;
                font-size: 12px;
                max-height: 25vh;
                overflow-y: auto;
                justify-content: space-between;
            }

            #controls label {
                margin: 0 2px;
                flex: 0 1 auto;
                display: flex;
                flex-direction: column;
                align-items: center;
                font-size: 10px;
            }

            #controls select,
            #controls input,
            #controls button {
                font-size: 11px;
                padding: 4px 6px;
                margin: 2px 0;
                border-radius: 4px;
                min-height: 32px;
                max-width: 80px;
            }

            #functionSelect,
            #toolSelect {
                max-width: 100px;
            }

            .canvas-container {
                flex: 1;
                display: flex;
                flex-direction: column;
                gap: 5px;
                padding: 5px;
                margin: 0;
                position: relative;
                min-height: 0;
            }

            .canvas-wrapper {
                flex: 1;
                position: relative;
                min-height: 150px;
            }

            canvas {
                width: 100% !important;
                height: 100% !important;
                border: 1px solid #666;
                touch-action: none;
            }

            .canvas-label {
                font-size: 12px;
                padding: 3px 8px;
                background: rgba(0, 0, 0, 0.8);
                border-radius: 3px;
                position: absolute;
                top: 5px;
                left: 5px;
                z-index: 10;
            }

            .zoom-value {
                font-size: 11px;
                min-width: 35px;
                text-align: center;
            }

            #tooltip {
                font-size: 11px;
                padding: 4px 8px;
                max-width: 200px;
                word-wrap: break-word;
            }
        }

        /* Optimized for modern phones like Galaxy S20 FE (~408px width) */
        @media (max-width: 430px) and (min-width: 390px) {
            body {
                overflow-x: hidden;
                overflow-y: auto;
                /* Allow vertical scrolling on mobile */
            }

            #controls {
                padding: 3px 5px;
                gap: 3px;
                min-height: 38px;
                font-size: 10px;
            }

            #controls select,
            #controls input,
            #controls button {
                font-size: 10px;
                padding: 3px 4px;
                min-height: 24px;
            }

            .directional-controls {
                width: 130px;
                height: 130px;
                gap: 8px;
                bottom: 75px;
                /* Adjusted to match canvas spacing */
                right: 12px;
            }

            .direction-btn {
                font-size: 26px;
                min-height: 38px;
            }
        }

        @media (max-width: 480px) {
            body {
                overflow-x: hidden;
                overflow-y: auto;
                /* Allow vertical scrolling on mobile */
            }

            #controls {
                font-size: 10px;
                padding: 2px 4px;
                gap: 2px;
                min-height: 32px;
            }

            #controls select,
            #controls input,
            #controls button {
                font-size: 9px;
                padding: 1px 2px;
                min-height: 20px;
            }

            #controls label {
                font-size: 9px;
            }

            .directional-controls {
                bottom: 30px;
                /* Back to normal positioning */
            }
        }

        .main-content {
            display: flex;
            flex: 1;
            height: calc(100vh - 40px);
        }

        @media (max-width: 768px) {
            .main-content {
                height: calc(100vh - 25vh);
                flex-direction: column;
                position: fixed;
                top: 25vh;
                left: 0;
                right: 0;
                bottom: 0;
            }
        }

        @media (max-width: 480px) {
            .main-content {
                height: calc(100vh - 25vh);
            }
        }

        /* Landscape mobile orientation */
        @media (max-width: 768px) and (orientation: landscape) {
            #controls {
                max-height: 30vh;
                padding: 5px;
            }

            .canvas-container {
                top: 30vh;
                bottom: 50px;
                /* Reduced to give more space to canvases in landscape */
                flex-direction: row;
                gap: 8px;
            }

            .directional-controls {
                bottom: 60px;
                /* Adjusted for landscape mode */
            }

            .canvas-wrapper {
                flex: 1;
                min-height: 120px;
            }

            .zoom-slider-container {
                position: fixed;
                bottom: 5px;
                right: 5px;
                left: auto;
                transform: none;
                flex-direction: column;
                padding: 5px 8px;
                writing-mode: vertical-lr !important;
                text-orientation: mixed !important;
                width: auto !important;
                height: auto !important;
            }

            .zoom-slider-container input[type="range"] {
                width: 80px;
                -webkit-appearance: slider-vertical !important;
                appearance: slider-vertical !important;
                writing-mode: bt-lr !important;
                height: 80px !important;
            }

            .zoom-slider-container label,
            .zoom-slider-container .zoom-value {
                writing-mode: vertical-lr !important;
                text-orientation: mixed !important;
            }
        }

        #controls input,
        #controls select {
            color: #000;
            padding: 2px 4px;
            transition: all 0.3s;
        }

        body.light-mode #controls input,
        body.light-mode #controls select {
            background: #fff;
            border: 1px solid #ccc;
        }

        body.light-mode #controls button {
            background: #f0f0f0;
            color: #333;
            border: 1px solid #ccc;
        }

        .canvas-container {
            position: relative;
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            /* Prevent flex overflow */
        }

        /* Zoom Slider Between Canvases */
        .zoom-slider-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.1);
            flex-direction: column;
            min-width: 40px;
            max-width: 60px;
            writing-mode: vertical-lr;
            text-orientation: mixed;
        }

        .zoom-slider {
            writing-mode: bt-lr;
            /* IE */
            -webkit-appearance: slider-vertical;
            /* WebKit */
            appearance: slider-vertical;
            /* Standard */
            width: 10px;
            height: 150px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            border-radius: 5px;
        }

        .zoom-label {
            font-size: 10px;
            color: inherit;
            writing-mode: vertical-lr;
            text-orientation: mixed;
            margin: 0;
        }

        .zoom-value {
            font-size: 9px;
            color: inherit;
            writing-mode: vertical-lr;
            text-orientation: mixed;
            min-height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Mobile responsive adjustments */
        @media (max-width: 768px) {
            .zoom-slider-container {
                flex-direction: row !important;
                writing-mode: initial !important;
                text-orientation: initial !important;
                min-width: auto !important;
                max-width: none !important;
                width: 100% !important;
                height: 50px !important;
                position: relative !important;
                bottom: auto !important;
                left: auto !important;
                right: auto !important;
                transform: none !important;
                background: rgba(0, 0, 0, 0.1) !important;
                padding: 8px !important;
                border-radius: 0 !important;
                backdrop-filter: none !important;
                z-index: auto !important;
                box-shadow: none !important;
            }

            .zoom-slider {
                -webkit-appearance: auto !important;
                appearance: auto !important;
                writing-mode: initial !important;
                width: 200px !important;
                height: 10px !important;
                margin: 0 !important;
            }

            .zoom-label,
            .zoom-value {
                writing-mode: initial !important;
                text-orientation: initial !important;
                min-height: auto !important;
                font-size: 12px !important;
            }

            .canvas-container {
                flex: 1;
                min-height: 0;
            }

            .canvas-label {
                font-size: 12px;
                margin-bottom: 2px;
            }
        }

        .canvas-label {
            text-align: center;
            color: #aaa;
            margin-bottom: 4px;
            font-size: 14px;
        }

        canvas {
            flex: 1;
            background: #222;
            cursor: crosshair;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            /* Prevent zoom on double tap */
            -ms-touch-action: manipulation;
            -webkit-user-drag: none;
        }

        .domain {
            border-right: 2px solid #555;
        }

        .codomain {
            border-left: 2px solid #555;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 2px 4px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            white-space: nowrap;
            z-index: 20;
        }

        .directional-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            gap: 5px;
            width: 80px;
            height: 80px;
            z-index: 15;
        }

        /* Make directional controls more visible on mobile */
        @media (max-width: 768px) {
            .directional-controls {
                width: 120px;
                height: 120px;
                gap: 10px;
                bottom: 70px;
                /* Reduced to match canvas spacing */
                right: 10px;
                background: rgba(0, 0, 0, 0.3);
                border-radius: 8px;
                padding: 5px;
            }

            .direction-btn {
                font-size: 24px;
                border-width: 2px;
                background: rgba(0, 0, 0, 0.9);
                min-height: 35px;
                border-radius: 6px;
            }
        }

        @media (max-width: 480px) {
            .directional-controls {
                width: 140px;
                height: 140px;
                gap: 12px;
                bottom: 85px;
                /* Adjusted for better spacing on small screens */
                right: 15px;
            }

            .direction-btn {
                font-size: 28px;
                border-width: 3px;
                min-height: 40px;
            }
        }

        .direction-btn {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #555;
            color: #fff;
            font-size: 16px;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            transition: background-color 0.2s;
            touch-action: manipulation;
            /* Improve touch responsiveness */
        }

        .direction-btn:hover {
            background: rgba(0, 0, 0, 0.9);
        }

        .direction-btn:active {
            background: rgba(255, 255, 255, 0.2);
        }

        .direction-btn.up {
            grid-column: 2;
            grid-row: 1;
        }

        .direction-btn.left {
            grid-column: 1;
            grid-row: 2;
        }

        .direction-btn.right {
            grid-column: 3;
            grid-row: 2;
        }

        .direction-btn.down {
            grid-column: 2;
            grid-row: 3;
        }

        .direction-btn.center {
            grid-column: 2;
            grid-row: 2;
            font-size: 16px;
            background: rgba(70, 130, 180, 0.9);
        }

        .direction-btn.center:hover {
            background: rgba(70, 130, 180, 1);
        }

        .help-btn {
            position: fixed;
            bottom: 15px;
            left: 15px;
            width: 40px;
            height: 40px;
            background: rgba(200, 50, 50, 0.9);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            z-index: 20;
            transition: all 0.3s;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .export-btn {
            position: fixed;
            bottom: 15px;
            left: 65px;
            width: 40px;
            height: 40px;
            background: rgba(50, 150, 50, 0.9);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            z-index: 20;
            transition: all 0.3s;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .export-btn:hover {
            background: rgba(50, 150, 50, 1);
            transform: scale(1.1);
        }

        .help-btn:hover {
            background: rgba(220, 70, 70, 1);
            transform: scale(1.1);
        }

        .hover-tooltip {
            position: fixed;
            bottom: 45px;
            left: 10px;
            background: rgba(0, 0, 0, 0.9);
            color: #4ecdc4;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 13px;
            max-width: 300px;
            line-height: 1.4;
            display: none;
            z-index: 25;
            border: 1px solid #4ecdc4;
        }

        /* Mobile improvements for tooltip */
        @media (max-width: 768px) {
            .hover-tooltip {
                max-width: calc(100vw - 20px);
                left: 10px;
                right: 10px;
                width: auto;
                font-size: 12px;
            }
        }

        .help-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .help-content {
            max-width: 800px;
            margin: 20px auto;
            padding: 30px;
            background: #1a1a1a;
            border-radius: 10px;
            color: #eee;
            line-height: 1.6;
            border: 2px solid #444;
        }

        /* Mobile help modal improvements */
        @media (max-width: 768px) {
            body {
                /* Override the main overflow: hidden for mobile to allow scrolling */
                overflow: hidden;
                /* Keep horizontal hidden */
                overflow-y: auto;
                /* Allow vertical scrolling */
            }

            .help-modal {
                /* Ensure modal can scroll properly on mobile */
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                /* Handle potential issues with mobile browsers */
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                height: 100vh;
                /* Use viewport height */
                width: 100vw;
                /* Use viewport width */
            }

            .help-content {
                margin: 10px;
                padding: 20px;
                max-width: none;
                border-radius: 8px;
                font-size: 14px;
                /* Ensure content doesn't get cut off */
                min-height: calc(100vh - 40px);
                box-sizing: border-box;
            }

            .help-content h1 {
                font-size: 22px;
                margin-bottom: 15px;
            }

            .help-content h2 {
                font-size: 18px;
                margin-top: 20px;
            }

            .help-content h3 {
                font-size: 16px;
                margin-top: 15px;
            }
        }

        .close-help {
            position: absolute;
            top: 15px;
            right: 20px;
            background: rgba(200, 50, 50, 0.9);
            color: white;
            border: none;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1001;
            touch-action: manipulation;
        }

        /* Mobile device specific improvements */
        body.mobile-device {
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        body.mobile-device .direction-btn {
            border-width: 2px;
            font-size: 20px;
            min-width: 35px;
            min-height: 35px;
        }

        body.mobile-device .help-btn,
        body.mobile-device .export-btn {
            min-width: 44px;
            min-height: 44px;
        }

        body.mobile-device #controls {
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
        }

        /* Prevent text selection on touch devices */
        .mobile-device * {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .mobile-device input,
        .mobile-device textarea {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }

        .help-content h1 {
            color: #ff6b6b;
            text-align: center;
            font-size: 28px;
            margin-bottom: 20px;
        }

        .help-content h2 {
            color: #4ecdc4;
            border-bottom: 2px solid #4ecdc4;
            padding-bottom: 5px;
            margin-top: 30px;
        }

        .help-content h3 {
            color: #ffe66d;
            margin-top: 20px;
        }

        .help-content code {
            background: #333;
            padding: 2px 5px;
            border-radius: 3px;
            color: #ff6b6b;
        }

        .help-content .math {
            background: #2a2a2a;
            padding: 10px;
            border-left: 4px solid #4ecdc4;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
        }

        .help-content .example {
            background: #2a2a3a;
            padding: 15px;
            border-left: 4px solid #ffe66d;
            margin: 10px 0;
            border-radius: 5px;
        }

        .close-help {
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 30px;
            cursor: pointer;
            color: #ff6b6b;
        }

        .canvas-help {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #4ecdc4;
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 14px;
            max-width: 90%;
            text-align: center;
            display: none;
            z-index: 15;
        }
    </style>
</head>

<body>
    <!-- Mobile Disclaimer Modal -->
    <div id="mobileDisclaimer"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 10000; color: white; padding: 20px; box-sizing: border-box;">
        <div style="max-width: 400px; margin: 50px auto; text-align: center;">
            <h2 style="color: #ff6b6b; margin-bottom: 20px;">üì± Mobile Notice</h2>
            <p style="font-size: 16px; line-height: 1.5; margin-bottom: 20px;">
                This Complex Function Visualizer is designed for <strong>desktop computers</strong> with mouse and
                keyboard for the best experience.
            </p>
            <p style="font-size: 14px; line-height: 1.5; margin-bottom: 30px;">
                On mobile, some features may be limited and the interface condensed, but you can still explore complex
                functions! Use two fingers to pan/zoom and one finger to draw.
            </p>
            <button id="continueAnyway"
                style="background: #4ecdc4; color: white; border: none; padding: 15px 30px; border-radius: 25px; font-size: 16px; cursor: pointer; margin-right: 10px;">
                Continue Anyway üì±
            </button>
            <button id="goToDesktop"
                style="background: #ffe66d; color: #333; border: none; padding: 15px 30px; border-radius: 25px; font-size: 16px; cursor: pointer;">
                Use Desktop Instead üíª
            </button>
        </div>
    </div>

    <div id="controls">
        <label>Function:
            <select id="functionSelect">
                <option value="z2">z¬≤</option>
                <option value="z3">z¬≥</option>
                <option value="z4">z‚Å¥</option>
                <option value="inv">1/z</option>
                <option value="log">log(z)</option>
                <option value="exp">e^z</option>
                <option value="sin">sin(z)</option>
                <option value="cos">cos(z)</option>
                <option value="sqrt">‚àöz</option>
                <option value="zbar">conjugate(z)</option>
                <option value="mobius">(z-1)/(z+1)</option>
                <option value="quadratic">z¬≤+z</option>
                <option value="real_poly">x¬≤-y¬≤ (real part only)</option>
            </select>
        </label>
        <label>Tool:
            <select id="toolSelect">
                <option value="freehand">Freehand</option>
                <option value="line">Line</option>
                <option value="circle">Circle</option>
                <option value="polygon">Polygon</option>
                <option value="sine">Sine Wave</option>
                <option value="spiral">Spiral</option>
                <option value="star">Star</option>
                <option value="dot">Dot</option>
                <option value="etch">Etch-a-Sketch</option>
                <option value="chessboard">Integer Grid</option>
                <option value="text">Text</option>
                <option value="image">Image</option>
            </select>
        </label>
        <label id="paramLabel" style="display:none">
            Turns/Sides:
            <input type="number" id="paramInput" value="5" min="3" max="20" step="1" style="width:35px" />
        </label>
        <label id="textLabel" style="display:none">
            Text:
            <input type="text" id="textInput" value="Hello" placeholder="Enter text" style="width:60px" />
            Size:
            <input type="number" id="fontSizeInput" value="24" min="8" max="72" step="1" style="width:30px" />
            Color:
            <input type="color" id="fontColorInput" value="#ffffff" style="width:25px" />
            Font:
            <select id="fontFamilyInput" style="width:60px">
                <option value="Arial">Arial</option>
                <option value="Times">Times</option>
                <option value="Courier">Courier</option>
                <option value="Georgia">Georgia</option>
                <option value="Verdana">Verdana</option>
                <option value="Impact">Impact</option>
                <option value="Comic Sans MS">Comic</option>
            </select>
        </label>
        <button id="undoBtn">Undo</button>
        <button id="clearBtn">Clear</button>
        <label><input type="checkbox" id="continuousToggle" checked /> Continuous</label>
        <label><input type="checkbox" id="snapToGridToggle" /> Snap grid</label>
        <button id="themeToggle"
            style="background: #444; color: #eee; border: 1px solid #666; padding: 2px 6px; border-radius: 3px; cursor: pointer; font-size: 11px;">üåô</button>
    </div>

    <div class="main-content">
        <!-- Single Help Button -->
        <button class="help-btn" id="helpBtn">?</button>
        <button class="export-btn" id="exportBtn">‚¨á</button>
        <div id="hoverTooltip" class="hover-tooltip"></div>

        <div id="tooltip" class="tooltip" style="display:none;"></div>
        <div class="canvas-container">
            <div class="canvas-label" id="domainLabel">Input Plane</div>
            <canvas id="canvasDomain" class="domain"></canvas>
            <div class="directional-controls">
                <div class="direction-btn up" data-direction="up">‚Üë</div>
                <div class="direction-btn left" data-direction="left">‚Üê</div>
                <div class="direction-btn center" id="resetBtn">‚åÇ</div>
                <div class="direction-btn right" data-direction="right">‚Üí</div>
                <div class="direction-btn down" data-direction="down">‚Üì</div>
            </div>
        </div>

        <!-- Zoom Slider Between Canvases -->
        <div class="zoom-slider-container">
            <label id="zoomSliderLabel" class="zoom-label">üîç</label>
            <input type="range" id="zoomSlider" min="0.33" max="3" step="0.1" value="1" class="zoom-slider" />
            <span class="zoom-value">1.0x</span>
        </div>

        <div class="canvas-container">
            <div class="canvas-label" id="codomainLabel">Output Plane</div>
            <canvas id="canvasCodomain" class="codomain"></canvas>
            <div class="directional-controls">
                <div class="direction-btn up" data-direction="up">‚Üë</div>
                <div class="direction-btn left" data-direction="left">‚Üê</div>
                <div class="direction-btn center" id="resetBtn2">‚åÇ</div>
                <div class="direction-btn right" data-direction="right">‚Üí</div>
                <div class="direction-btn down" data-direction="down">‚Üì</div>
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="helpModal" class="help-modal">
        <div class="help-content">
            <button class="close-help" id="closeHelp">√ó</button>
            <div id="helpText"></div>
        </div>
    </div>
    <script>
        const canvases = { domain: document.getElementById('canvasDomain'), codomain: document.getElementById('canvasCodomain') };
        const ctx = { domain: canvases.domain.getContext('2d'), codomain: canvases.codomain.getContext('2d') };
        const functionSelect = document.getElementById('functionSelect');
        const toolSelect = document.getElementById('toolSelect');
        const paramLabel = document.getElementById('paramLabel');
        const paramInput = document.getElementById('paramInput');
        const textLabel = document.getElementById('textLabel');
        const textInput = document.getElementById('textInput');
        const fontSizeInput = document.getElementById('fontSizeInput');
        const fontColorInput = document.getElementById('fontColorInput');
        const fontFamilyInput = document.getElementById('fontFamilyInput');
        const clearBtn = document.getElementById('clearBtn');
        const undoBtn = document.getElementById('undoBtn');
        const resetBtn = document.getElementById('resetBtn');
        const resetBtn2 = document.getElementById('resetBtn2');
        const continuousToggle = document.getElementById('continuousToggle');
        const snapToGridToggle = document.getElementById('snapToGridToggle');
        const tooltip = document.getElementById('tooltip');
        const themeToggle = document.getElementById('themeToggle');
        const domainLabel = document.getElementById('domainLabel');
        const codomainLabel = document.getElementById('codomainLabel');

        // Theme management
        let isDarkMode = true;

        // Mobile device detection and optimization
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                (window.innerWidth <= 768 && 'ontouchstart' in window);
        }

        function isIOSDevice() {
            return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        }

        // Initialize mobile-specific features
        function initMobileFeatures() {
            if (isMobileDevice()) {
                // Show mobile disclaimer
                showMobileDisclaimer();

                // Add mobile class to body for additional styling
                document.body.classList.add('mobile-device');

                // Disable double-tap zoom on buttons and controls
                document.querySelectorAll('button, select, input').forEach(el => {
                    el.style.touchAction = 'manipulation';
                });

                // iOS-specific fixes
                if (isIOSDevice()) {
                    // Prevent iOS Safari from zooming on input focus
                    document.querySelectorAll('input, select').forEach(el => {
                        if (el.style.fontSize === '' || parseInt(el.style.fontSize) < 16) {
                            el.style.fontSize = '16px';
                        }
                    });

                    // Fix iOS viewport height issues
                    const updateViewportHeight = () => {
                        document.documentElement.style.setProperty('--vh', `${window.innerHeight * 0.01}px`);
                    };
                    updateViewportHeight();
                    window.addEventListener('resize', updateViewportHeight);
                    window.addEventListener('orientationchange', updateViewportHeight);
                }

                // Android-specific fixes
                if (/Android/i.test(navigator.userAgent)) {
                    // Improve performance on Android devices
                    document.querySelectorAll('canvas').forEach(canvas => {
                        canvas.style.transform = 'translateZ(0)'; // Enable hardware acceleration
                    });
                }
            }
        }

        // Mobile disclaimer functionality
        function showMobileDisclaimer() {
            const disclaimer = document.getElementById('mobileDisclaimer');
            disclaimer.style.display = 'block';

            document.getElementById('continueAnyway').onclick = () => {
                disclaimer.style.display = 'none';
                // Show mobile help hint after disclaimer
                setTimeout(() => {
                    showNotification('Tip: Use 2 fingers to pan/zoom, 1 finger to draw!', 'domain');
                }, 500);
            };

            document.getElementById('goToDesktop').onclick = () => {
                const isConfirmed = confirm('This will redirect you to learn about accessing this tool on a desktop computer.');
                if (isConfirmed) {
                    // Could redirect to a help page or show more info
                    alert('For the best experience, open this page on a desktop or laptop computer with a mouse and keyboard.');
                    disclaimer.style.display = 'none';
                }
            };
        }

        // Polyfill for older browsers
        if (!window.navigator.vibrate) {
            window.navigator.vibrate = () => { }; // No-op fallback
        }

        // Function to update canvas and axis labels based on selected function
        function updateLabels() {
            const fn = functionSelect.value;
            let inputLabel, outputLabel, inputVar, outputVar, inputRealLabel, inputImagLabel, outputRealLabel, outputImagLabel;

            switch (fn) {
                case 'z2':
                    inputLabel = 'z plane (input)';
                    outputLabel = 'z¬≤ plane (output)';
                    inputVar = 'z';
                    outputVar = 'w = z¬≤';
                    inputRealLabel = 'Re(z)';
                    inputImagLabel = 'Im(z)';
                    outputRealLabel = 'Re(z¬≤)';
                    outputImagLabel = 'Im(z¬≤)';
                    break;
                case 'z3':
                    inputLabel = 'z plane (input)';
                    outputLabel = 'z¬≥ plane (output)';
                    inputVar = 'z';
                    outputVar = 'w = z¬≥';
                    inputRealLabel = 'Re(z)';
                    inputImagLabel = 'Im(z)';
                    outputRealLabel = 'Re(z¬≥)';
                    outputImagLabel = 'Im(z¬≥)';
                    break;
                case 'z4':
                    inputLabel = 'z plane (input)';
                    outputLabel = 'z‚Å¥ plane (output)';
                    inputVar = 'z';
                    outputVar = 'w = z‚Å¥';
                    inputRealLabel = 'Re(z)';
                    inputImagLabel = 'Im(z)';
                    outputRealLabel = 'Re(z‚Å¥)';
                    outputImagLabel = 'Im(z‚Å¥)';
                    break;
                case 'inv':
                    inputLabel = 'z plane (input)';
                    outputLabel = '1/z plane (output)';
                    inputVar = 'z';
                    outputVar = 'w = 1/z';
                    inputRealLabel = 'Re(z)';
                    inputImagLabel = 'Im(z)';
                    outputRealLabel = 'Re(1/z)';
                    outputImagLabel = 'Im(1/z)';
                    break;
                case 'log':
                    inputLabel = 'z plane (input)';
                    outputLabel = 'log(z) plane (output)';
                    inputVar = 'z';
                    outputVar = 'w = log(z)';
                    inputRealLabel = 'Re(z)';
                    inputImagLabel = 'Im(z)';
                    outputRealLabel = 'ln|z|';
                    outputImagLabel = 'arg(z)';
                    break;
                case 'exp':
                    inputLabel = 'z plane (input)';
                    outputLabel = 'e·∂ª plane (output)';
                    inputVar = 'z';
                    outputVar = 'w = e·∂ª';
                    inputRealLabel = 'Re(z)';
                    inputImagLabel = 'Im(z)';
                    outputRealLabel = 'eÀ£ cos(y)';
                    outputImagLabel = 'eÀ£ sin(y)';
                    break;
                case 'sin':
                    inputLabel = 'z plane (input)';
                    outputLabel = 'sin(z) plane (output)';
                    inputVar = 'z';
                    outputVar = 'w = sin(z)';
                    inputRealLabel = 'Re(z)';
                    inputImagLabel = 'Im(z)';
                    outputRealLabel = 'Re(sin z)';
                    outputImagLabel = 'Im(sin z)';
                    break;
                case 'cos':
                    inputLabel = 'z plane (input)';
                    outputLabel = 'cos(z) plane (output)';
                    inputVar = 'z';
                    outputVar = 'w = cos(z)';
                    inputRealLabel = 'Re(z)';
                    inputImagLabel = 'Im(z)';
                    outputRealLabel = 'Re(cos z)';
                    outputImagLabel = 'Im(cos z)';
                    break;
                case 'sqrt':
                    inputLabel = 'z plane (input)';
                    outputLabel = '‚àöz plane (output)';
                    inputVar = 'z';
                    outputVar = 'w = ‚àöz';
                    inputRealLabel = 'Re(z)';
                    inputImagLabel = 'Im(z)';
                    outputRealLabel = 'Re(‚àöz)';
                    outputImagLabel = 'Im(‚àöz)';
                    break;
                case 'zbar':
                    inputLabel = 'z plane (input)';
                    outputLabel = 'zÃÑ plane (output)';
                    inputVar = 'z';
                    outputVar = 'w = zÃÑ';
                    inputRealLabel = 'Re(z)';
                    inputImagLabel = 'Im(z)';
                    outputRealLabel = 'Re(zÃÑ)';
                    outputImagLabel = 'Im(zÃÑ)';
                    break;
                case 'mobius':
                    inputLabel = 'z plane (input)';
                    outputLabel = '(z-1)/(z+1) plane (output)';
                    inputVar = 'z';
                    outputVar = 'w = (z-1)/(z+1)';
                    inputRealLabel = 'Re(z)';
                    inputImagLabel = 'Im(z)';
                    outputRealLabel = 'Re(w)';
                    outputImagLabel = 'Im(w)';
                    break;
                case 'quadratic':
                    inputLabel = 'z plane (input)';
                    outputLabel = 'z¬≤+z plane (output)';
                    inputVar = 'z';
                    outputVar = 'w = z¬≤+z';
                    inputRealLabel = 'Re(z)';
                    inputImagLabel = 'Im(z)';
                    outputRealLabel = 'Re(z¬≤+z)';
                    outputImagLabel = 'Im(z¬≤+z)';
                    break;
                case 'real_poly':
                    inputLabel = 'Input plane (x,y)';
                    outputLabel = 'Output plane (u,v)';
                    inputVar = 'z = x + iy';
                    outputVar = 'u = x¬≤-y¬≤, v = 0';
                    inputRealLabel = 'x';
                    inputImagLabel = 'y';
                    outputRealLabel = 'u';
                    outputImagLabel = 'v';
                    break;
                default:
                    inputLabel = 'z plane (input)';
                    outputLabel = 'w plane (output)';
                    inputVar = 'z';
                    outputVar = 'w = f(z)';
                    inputRealLabel = 'Re(z)';
                    inputImagLabel = 'Im(z)';
                    outputRealLabel = 'Re(w)';
                    outputImagLabel = 'Im(w)';
            }

            // Update canvas labels
            domainLabel.textContent = inputLabel;
            codomainLabel.textContent = outputLabel;

            // Store labels for use in grid drawing
            window.currentLabels = {
                inputRealLabel,
                inputImagLabel,
                outputRealLabel,
                outputImagLabel
            };
        }

        function toggleTheme() {
            isDarkMode = !isDarkMode;
            document.body.classList.toggle('light-mode', !isDarkMode);
            themeToggle.textContent = isDarkMode ? 'üåô' : '‚òÄÔ∏è';
            themeToggle.style.background = isDarkMode ? '#444' : '#f0f0f0';
            themeToggle.style.color = isDarkMode ? '#eee' : '#333';

            // Update canvas backgrounds programmatically
            setTimeout(() => {
                redrawAll();
            }, 100);
        }

        // Initialize theme toggle
        themeToggle.addEventListener('click', toggleTheme);

        let origin = {}, baseScale = 40, scale = baseScale;
        let isDrawing = false, startPt = null, currentPts = [], activeCanvas = 'domain';
        const MAX_STROKES = 6, strokes = [], dots = [], texts = [], images = [];

        // Snap to grid state
        let snapToGrid = false;

        // Touch gesture state
        let isTouching = false;
        let touchStartDistance = 0;
        let touchStartCenter = { x: 0, y: 0 };
        let touchGestureMode = 'none'; // 'none', 'pan', 'draw'
        let touchStartTime = 0;
        let lastPanPosition = null;

        // Chessboard state
        let chessboard = null;
        let isDraggingCorner = false;
        let dragCornerIndex = -1;
        let isDraggingChessboard = false;
        let chessboardDragOffset = { x: 0, y: 0 };

        // Text and image state
        let pendingText = null;
        let isDragOver = false;
        let isDraggingImage = false;
        let draggedImageIndex = -1;
        let imageDragOffset = { x: 0, y: 0 };

        // Text and image corner dragging state
        let isDraggingTextCorner = false;
        let draggedTextIndex = -1;
        let draggedTextCornerIndex = -1;
        let isDraggingText = false;
        let textDragOffset = { x: 0, y: 0 };
        let isDraggingImageCorner = false;
        let draggedImageCornerIndex = -1;

        // Modifier key state for different drag modes
        let isShiftPressed = false;
        let isCtrlPressed = false;

        // Performance and quality optimization settings
        const PERFORMANCE_SETTINGS = {
            MAX_SAMPLE_DENSITY: 400, // Maximum samples per dimension
            MIN_SAMPLE_STEP: 0.5,    // Minimum step size for high quality
            CIRCLE_OVERLAP: 2.0,     // Circle size multiplier for better coverage
            ALPHA_THRESHOLD: 25,     // Minimum alpha to process
            QUALITY_LEVELS: {
                LOW: { density: 0.3, overlap: 1.5 },
                MEDIUM: { density: 0.6, overlap: 2.0 },
                HIGH: { density: 1.0, overlap: 2.5 }
            }
        };

        // Auto-adjust quality based on content size
        function getQualityLevel(contentSize) {
            if (contentSize < 5000) return PERFORMANCE_SETTINGS.QUALITY_LEVELS.HIGH;
            if (contentSize < 20000) return PERFORMANCE_SETTINGS.QUALITY_LEVELS.MEDIUM;
            return PERFORMANCE_SETTINGS.QUALITY_LEVELS.LOW;
        }

        // Mathematical functions
        function getUserFunction() {
            const fn = functionSelect.value;
            switch (fn) {
                case 'z2': return z => ({ re: z.re * z.re - z.im * z.im, im: 2 * z.re * z.im });
                case 'z3': return z => {
                    const r2 = z.re * z.re - z.im * z.im;
                    const i2 = 2 * z.re * z.im;
                    return { re: r2 * z.re - i2 * z.im, im: r2 * z.im + i2 * z.re };
                };
                case 'z4': return z => {
                    const z2 = { re: z.re * z.re - z.im * z.im, im: 2 * z.re * z.im };
                    return { re: z2.re * z2.re - z2.im * z2.im, im: 2 * z2.re * z2.im };
                };
                case 'inv': return z => {
                    const denom = z.re * z.re + z.im * z.im;
                    if (denom === 0) return { re: Infinity, im: Infinity };
                    return { re: z.re / denom, im: -z.im / denom };
                };
                case 'log': return z => {
                    const r = Math.hypot(z.re, z.im);
                    if (r === 0) return { re: -Infinity, im: 0 };
                    return { re: Math.log(r), im: Math.atan2(z.im, z.re) };
                };
                case 'exp': return z => {
                    const exp_re = Math.exp(z.re);
                    return { re: exp_re * Math.cos(z.im), im: exp_re * Math.sin(z.im) };
                };
                case 'sin': return z => {
                    const exp_iz = { re: -z.im, im: z.re };
                    const exp_neg_iz = { re: z.im, im: -z.re };
                    const e1 = getUserFunction().exp ? getUserFunction().exp(exp_iz) :
                        { re: Math.exp(-z.im) * Math.cos(z.re), im: Math.exp(-z.im) * Math.sin(z.re) };
                    const e2 = getUserFunction().exp ? getUserFunction().exp(exp_neg_iz) :
                        { re: Math.exp(z.im) * Math.cos(-z.re), im: Math.exp(z.im) * Math.sin(-z.re) };
                    return { re: (e1.re - e2.re) / 2, im: (e1.im - e2.im) / 2 };
                };
                case 'cos': return z => {
                    const exp_iz = { re: -z.im, im: z.re };
                    const exp_neg_iz = { re: z.im, im: -z.re };
                    const e1 = { re: Math.exp(-z.im) * Math.cos(z.re), im: Math.exp(-z.im) * Math.sin(z.re) };
                    const e2 = { re: Math.exp(z.im) * Math.cos(-z.re), im: Math.exp(z.im) * Math.sin(-z.re) };
                    return { re: (e1.re + e2.re) / 2, im: (e1.im + e2.im) / 2 };
                };
                case 'sqrt': return z => {
                    const r = Math.hypot(z.re, z.im);
                    const t = Math.atan2(z.im, z.re);
                    const rr = Math.sqrt(r);
                    const ang = t / 2;
                    return { re: rr * Math.cos(ang), im: rr * Math.sin(ang) };
                };
                case 'zbar': return z => ({ re: z.re, im: -z.im });
                case 'mobius': return z => {
                    const num = { re: z.re - 1, im: z.im };
                    const den = { re: z.re + 1, im: z.im };
                    const denom = den.re * den.re + den.im * den.im;
                    if (denom === 0) return { re: Infinity, im: Infinity };
                    return { re: (num.re * den.re + num.im * den.im) / denom, im: (num.im * den.re - num.re * den.im) / denom };
                };
                case 'quadratic': return z => {
                    const z2 = { re: z.re * z.re - z.im * z.im, im: 2 * z.re * z.im };
                    return { re: z2.re + z.re, im: z2.im + z.im };
                };
                case 'real_poly': return z => {
                    // Real polynomial: f(x,y) = (x¬≤-y¬≤, 0)
                    return { re: z.re * z.re - z.im * z.im, im: 0 };
                };
                default: return z => ({ re: z.re * z.re - z.im * z.im, im: 2 * z.re * z.im });
            }
        }

        function userFn(z) { return getUserFunction()(z); }
        let prevInv = null;
        function getInverseFunction() {
            const fn = functionSelect.value;
            switch (fn) {
                case 'z2': return w => {
                    const [r1, r2] = sqrtBranches(w);
                    return continuousToggle.checked ? chooseRoot(w) : r1;
                };
                case 'z3': return w => {
                    const r = Math.cbrt(Math.hypot(w.re, w.im));
                    const t = Math.atan2(w.im, w.re) / 3;
                    return { re: r * Math.cos(t), im: r * Math.sin(t) };
                };
                case 'z4': return w => {
                    const r = Math.pow(Math.hypot(w.re, w.im), 0.25);
                    const t = Math.atan2(w.im, w.re) / 4;
                    return { re: r * Math.cos(t), im: r * Math.sin(t) };
                };
                case 'inv': return w => {
                    const denom = w.re * w.re + w.im * w.im;
                    if (denom === 0) return { re: Infinity, im: Infinity };
                    return { re: w.re / denom, im: -w.im / denom };
                };
                case 'log': return w => {
                    return { re: Math.exp(w.re) * Math.cos(w.im), im: Math.exp(w.re) * Math.sin(w.im) };
                };
                case 'exp': return w => {
                    const r = Math.hypot(w.re, w.im);
                    if (r === 0) return { re: -Infinity, im: 0 };
                    return { re: Math.log(r), im: Math.atan2(w.im, w.re) };
                };
                case 'zbar': return w => ({ re: w.re, im: -w.im });
                case 'mobius': return w => {
                    const num = { re: w.re + 1, im: w.im };
                    const den = { re: 1 - w.re, im: -w.im };
                    const denom = den.re * den.re + den.im * den.im;
                    if (denom === 0) return { re: Infinity, im: Infinity };
                    return { re: (num.re * den.re + num.im * den.im) / denom, im: (num.im * den.re - num.re * den.im) / denom };
                };
                case 'sqrt': return w => ({ re: w.re * w.re - w.im * w.im, im: 2 * w.re * w.im });
                case 'real_poly': return w => {
                    // Inverse of x¬≤-y¬≤ = u, need to solve for x,y
                    // This is complex, so we'll use a simple approximation
                    return { re: Math.sqrt(Math.abs(w.re)), im: 0 };
                };
                default: return w => {
                    const [r1, r2] = sqrtBranches(w);
                    return continuousToggle.checked ? chooseRoot(w) : r1;
                };
            }
        }

        function sqrtBranches(w) { const r = Math.hypot(w.re, w.im), t = Math.atan2(w.im, w.re), rr = Math.sqrt(r), ang = t / 2; return [{ re: rr * Math.cos(ang), im: rr * Math.sin(ang) }, { re: -rr * Math.cos(ang), im: -rr * Math.sin(ang) }]; }
        function chooseRoot(w) { const [r1, r2] = sqrtBranches(w); if (!prevInv) prevInv = r1; const d1 = (r1.re - prevInv.re) ** 2 + (r1.im - prevInv.im) ** 2, d2 = (r2.re - prevInv.re) ** 2 + (r2.im - prevInv.im) ** 2; prevInv = d1 < d2 ? r1 : r2; return prevInv; }
        function invFn(w) { return getInverseFunction()(w); }

        // Helper function to get display coordinates that match the grid labels
        function getDisplayCoordinates(canvasX, canvasY, key) {
            // Get the same unitScale used in grid drawing
            const zoomVal = parseFloat(document.getElementById('zoomSlider').value) || 1;
            let unitScale;

            if (zoomVal < 0.5) {
                unitScale = 10;
            } else if (zoomVal < 1) {
                unitScale = 5;
            } else if (zoomVal <= 1.5) {
                unitScale = 1;
            } else if (zoomVal <= 2.5) {
                unitScale = 0.5;
            } else {
                unitScale = 0.2;
            }

            // Calculate grid steps from origin
            const originX = origin[key].x;
            const originY = origin[key].y;
            const gridStepsX = Math.round((canvasX - originX) / scale);
            const gridStepsY = -Math.round((canvasY - originY) / scale); // Negative because canvas y increases downward

            // Apply unit scaling to match grid labels
            const displayX = gridStepsX * unitScale;
            const displayY = gridStepsY * unitScale;

            return { re: displayX, im: displayY };
        }

        function toComplex(x, y, key) { return { re: (x - origin[key].x) / scale, im: (origin[key].y - y) / scale }; }
        function toCanvas(z, key) { return { x: origin[key].x + z.re * scale, y: origin[key].y - z.im * scale }; }

        // Snap to grid function
        function snapToGridPoint(x, y, key) {
            if (!snapToGrid) return { x, y };

            // Convert to complex coordinates
            const z = toComplex(x, y, key);

            // Snap to nearest integer
            const snappedZ = {
                re: Math.round(z.re),
                im: Math.round(z.im)
            };

            // Convert back to canvas coordinates
            return toCanvas(snappedZ, key);
        }

        let lastResizeTime = 0;
        let lastCanvasSize = { width: 0, height: 0 };

        function resize(skipThrottle = false) {
            // Throttle resize calls to prevent excessive resets, but allow immediate zoom updates
            if (!skipThrottle) {
                const now = Date.now();
                if (now - lastResizeTime < 50) return; // Minimum 50ms between resize calls
                lastResizeTime = now;
            }

            // adjust scale based on zoom slider
            const zoomVal = parseFloat(document.getElementById('zoomSlider').value) || 1;
            scale = baseScale * zoomVal;

            // Get actual canvas element sizes after CSS layout
            const domainRect = canvases.domain.getBoundingClientRect();
            const codomainRect = canvases.codomain.getBoundingClientRect();

            const newDomainWidth = Math.floor(domainRect.width);
            const newDomainHeight = Math.floor(domainRect.height);
            const newCodomainWidth = Math.floor(codomainRect.width);
            const newCodomainHeight = Math.floor(codomainRect.height);

            // Check if size actually changed to avoid unnecessary work
            // But always allow zoom updates when skipThrottle is true
            const sizeChanged = newDomainWidth !== lastCanvasSize.width || newDomainHeight !== lastCanvasSize.height;
            if (!sizeChanged && !skipThrottle) {
                return; // No size change and not a zoom update, so skip
            }

            // For zoom-only updates (skipThrottle=true, no size change), just update scale and redraw
            if (!sizeChanged && skipThrottle) {
                scale = baseScale * zoomVal;

                // Ensure origins are initialized for zoom-only updates
                if (!origin.domain || !origin.codomain) {
                    // Initialize origins to canvas centers if not already set
                    origin.domain = { x: canvases.domain.width / 2, y: canvases.domain.height / 2 };
                    origin.codomain = { x: canvases.codomain.width / 2, y: canvases.codomain.height / 2 };
                }

                redrawAll();
                return;
            }

            lastCanvasSize = { width: newDomainWidth, height: newDomainHeight };

            // Preserve current origin offsets before resize
            const oldDomainOrigin = origin.domain ? { ...origin.domain } : null;
            const oldCodomainOrigin = origin.codomain ? { ...origin.codomain } : null;
            const oldDomainCenter = oldDomainOrigin && canvases.domain.width > 0 ?
                { x: canvases.domain.width / 2, y: canvases.domain.height / 2 } : null;
            const oldCodomainCenter = oldCodomainOrigin && canvases.codomain.width > 0 ?
                { x: canvases.codomain.width / 2, y: canvases.codomain.height / 2 } : null;

            // Calculate pan offsets before resize
            const domainPanOffset = oldDomainOrigin && oldDomainCenter ? {
                x: oldDomainOrigin.x - oldDomainCenter.x,
                y: oldDomainOrigin.y - oldDomainCenter.y
            } : { x: 0, y: 0 };
            const codomainPanOffset = oldCodomainOrigin && oldCodomainCenter ? {
                x: oldCodomainOrigin.x - oldCodomainCenter.x,
                y: oldCodomainOrigin.y - oldCodomainCenter.y
            } : { x: 0, y: 0 };

            // Apply new canvas dimensions
            canvases.domain.width = newDomainWidth;
            canvases.domain.height = newDomainHeight;
            canvases.codomain.width = newCodomainWidth;
            canvases.codomain.height = newCodomainHeight;

            // Set new centers and restore pan offsets
            const newDomainCenter = { x: canvases.domain.width / 2, y: canvases.domain.height / 2 };
            const newCodomainCenter = { x: canvases.codomain.width / 2, y: canvases.codomain.height / 2 };

            origin.domain = {
                x: newDomainCenter.x + domainPanOffset.x,
                y: newDomainCenter.y + domainPanOffset.y
            };
            origin.codomain = {
                x: newCodomainCenter.x + codomainPanOffset.x,
                y: newCodomainCenter.y + codomainPanOffset.y
            };

            // Update chessboard scale if it exists
            if (chessboard && toolSelect.value === 'chessboard') {
                updateChessboardScale();
            }

            redrawAll();
        }

        function updateChessboardScale() {
            if (!chessboard) return;

            const gridSize = chessboard.gridSize || 5;

            // Use actual origin position (no snapping)
            const centerX = origin.domain.x;
            const centerY = origin.domain.y;
            const extent = gridSize * scale;

            // Update corners to match the new scale
            chessboard.corners = [
                { x: centerX - extent, y: centerY - extent }, // top-left
                { x: centerX + extent, y: centerY - extent }, // top-right
                { x: centerX + extent, y: centerY + extent }, // bottom-right
                { x: centerX - extent, y: centerY + extent }  // bottom-left
            ];
        }
        window.addEventListener('resize', resize);

        // Handle orientation changes on mobile - but only on actual orientation change, not every device movement
        let lastOrientation = window.orientation;
        window.addEventListener('orientationchange', () => {
            // Only resize if orientation actually changed
            if (window.orientation !== lastOrientation) {
                lastOrientation = window.orientation;
                setTimeout(() => {
                    resize();
                    updateAllTransformations();
                }, 100);
            }
        });

        // Prevent page refresh on pull-down gesture (iOS Safari)
        document.addEventListener('touchmove', (e) => {
            if (e.scale !== 1) {
                e.preventDefault();
            }
        }, { passive: false });

        // Remove problematic deviceorientation listener that was causing frequent resize calls
        // This was triggering resize on every tiny device movement, causing pan to reset
        // zoom slider listener with debounced transformation updates
        const zoomSlider = document.getElementById('zoomSlider');
        let zoomUpdateTimeout = null;
        let zoomAnimationFrame = null;
        let isZooming = false; // Track zoom state for performance optimizations

        zoomSlider.addEventListener('input', () => {
            isZooming = true; // Mark that we're in zoom mode

            // Direct zoom update without resize logic
            const zoomVal = parseFloat(zoomSlider.value) || 1;
            scale = baseScale * zoomVal;

            // Update zoom value display
            const zoomValueElement = document.querySelector('.zoom-value');
            if (zoomValueElement) {
                zoomValueElement.textContent = zoomVal.toFixed(1) + 'x';
            }

            // Cancel previous animation frame to prevent stacking
            if (zoomAnimationFrame) {
                cancelAnimationFrame(zoomAnimationFrame);
            }

            // Schedule smooth redraw with requestAnimationFrame
            zoomAnimationFrame = requestAnimationFrame(() => {
                redrawAll();
                zoomAnimationFrame = null;
            });

            // Debounce expensive transformation updates with shorter delay
            clearTimeout(zoomUpdateTimeout);
            zoomUpdateTimeout = setTimeout(() => {
                updateAllTransformations();
                isZooming = false; // Exit zoom mode after transformations complete
            }, 50); // Reduced from 100ms to 50ms for more responsive feedback
        });

        // Immediate update when user releases slider
        zoomSlider.addEventListener('change', () => {
            clearTimeout(zoomUpdateTimeout);
            if (zoomAnimationFrame) {
                cancelAnimationFrame(zoomAnimationFrame);
                zoomAnimationFrame = null;
            }
            updateAllTransformations();
            isZooming = false; // Exit zoom mode
        });

        // Update transformations when function changes
        functionSelect.addEventListener('change', () => {
            // Update labels first
            updateLabels();

            // Update all stroke transformations (lines, circles, stars, spirals, etc.)
            updateStrokeTransformations();

            // Update all image transformations
            images.forEach(img => updateImageTransformation(img));

            // Update all text transformations
            updateTextTransformations();

            redrawAll();
        });

        toolSelect.addEventListener('change', () => {
            paramLabel.style.display = (['spiral', 'star', 'polygon'].includes(toolSelect.value)) ? 'inline-block' : 'none';
            textLabel.style.display = (toolSelect.value === 'text') ? 'inline-block' : 'none';
            if (toolSelect.value === 'chessboard') {
                initChessboard();
            }
            if (toolSelect.value === 'image') {
                showImageInstructions();
            }
        });

        function drawGrid(key) {
            const c = canvases[key], g = ctx[key];
            g.clearRect(0, 0, c.width, c.height);

            // Set colors based on theme
            const gridColor = isDarkMode ? '#444' : '#ddd';
            const axisColor = isDarkMode ? '#888' : '#666';
            const textColor = isDarkMode ? '#ffffff' : '#000000';

            // Calculate offset to align background grid with axes
            const originX = origin[key].x;
            const originY = origin[key].y;
            const offsetX = originX % scale;
            const offsetY = originY % scale;

            // Draw background grid aligned with axes
            g.strokeStyle = gridColor;
            g.lineWidth = 1;

            // Vertical lines
            for (let x = offsetX; x < c.width; x += scale) {
                g.beginPath();
                g.moveTo(x, 0);
                g.lineTo(x, c.height);
                g.stroke();
            }
            for (let x = offsetX - scale; x >= 0; x -= scale) {
                g.beginPath();
                g.moveTo(x, 0);
                g.lineTo(x, c.height);
                g.stroke();
            }

            // Horizontal lines
            for (let y = offsetY; y < c.height; y += scale) {
                g.beginPath();
                g.moveTo(0, y);
                g.lineTo(c.width, y);
                g.stroke();
            }
            for (let y = offsetY - scale; y >= 0; y -= scale) {
                g.beginPath();
                g.moveTo(0, y);
                g.lineTo(c.width, y);
                g.stroke();
            }

            // Draw main axes at true origin positions
            g.strokeStyle = axisColor;
            g.lineWidth = 2;
            g.beginPath();
            g.moveTo(originX, 0);
            g.lineTo(originX, c.height);
            g.stroke();
            g.beginPath();
            g.moveTo(0, originY);
            g.lineTo(c.width, originY);
            g.stroke();

            // Determine appropriate step size and unit scale based on zoom
            const zoomVal = parseFloat(document.getElementById('zoomSlider').value) || 1;
            let step, unitScale;

            if (zoomVal < 0.5) {
                step = 1;
                unitScale = 10; // Show 10, 20, 30, etc.
            } else if (zoomVal < 1) {
                step = 1;
                unitScale = 5; // Show 5, 10, 15, etc.
            } else if (zoomVal <= 1.5) {
                step = 1;
                unitScale = 1; // Show 1, 2, 3, etc.
            } else if (zoomVal <= 2.5) {
                step = 1;
                unitScale = 0.5; // Show 0.5, 1.0, 1.5, etc.
            } else {
                step = 1;
                unitScale = 0.2; // Show 0.2, 0.4, 0.6, etc.
            }

            // Get appropriate labels based on function
            const labels = window.currentLabels || {
                inputRealLabel: 'Re(z)',
                inputImagLabel: 'Im(z)',
                outputRealLabel: 'Re(w)',
                outputImagLabel: 'Im(w)'
            };

            const realLabel = key === 'domain' ? labels.inputRealLabel : labels.outputRealLabel;
            const imagLabel = key === 'domain' ? labels.inputImagLabel : labels.outputImagLabel;

            // Add axis labels with scaled numbers
            g.fillStyle = textColor;
            g.font = '12px Arial';
            g.textAlign = 'center';
            g.textBaseline = 'top';

            // Draw real axis labels (horizontal) - only on grid lines
            for (let x = offsetX; x <= c.width; x += scale * step) {
                if (Math.abs(x - originX) < 5) continue; // Skip origin

                // Calculate the mathematical value 
                const gridSteps = Math.round((x - originX) / scale);
                const mathValue = gridSteps * unitScale;

                if (x >= 20 && x <= c.width - 20 && Math.abs(mathValue) <= 20 * unitScale) {
                    const displayValue = unitScale < 1 ? mathValue.toFixed(1) : mathValue.toString();
                    g.fillText(displayValue, x, originY + 15);
                }
            }

            // Negative side for real axis
            for (let x = offsetX - scale * step; x >= 0; x -= scale * step) {
                if (Math.abs(x - originX) < 5) continue; // Skip origin

                const gridSteps = Math.round((x - originX) / scale);
                const mathValue = gridSteps * unitScale;

                if (x >= 20 && x <= c.width - 20 && Math.abs(mathValue) <= 20 * unitScale) {
                    const displayValue = unitScale < 1 ? mathValue.toFixed(1) : mathValue.toString();
                    g.fillText(displayValue, x, originY + 15);
                }
            }

            // Draw imaginary axis labels (vertical) - only on grid lines
            g.textAlign = 'left';
            g.textBaseline = 'middle';

            for (let y = offsetY; y <= c.height; y += scale * step) {
                if (Math.abs(y - originY) < 5) continue; // Skip origin

                // Calculate the mathematical value (negative because canvas y increases downward)
                const gridSteps = -Math.round((y - originY) / scale);
                const mathValue = gridSteps * unitScale;

                if (y >= 20 && y <= c.height - 20 && Math.abs(mathValue) <= 20 * unitScale) {
                    const displayValue = unitScale < 1 ? mathValue.toFixed(1) : mathValue.toString();

                    // Determine if we should show 'i' suffix based on the current function and plane
                    const shouldShowI = imagLabel.includes('Im(') || imagLabel.includes('i');
                    let label;

                    if (shouldShowI) {
                        // For complex functions, show 'i' suffix
                        if (mathValue === 1) {
                            label = 'i';
                        } else if (mathValue === -1) {
                            label = '-i';
                        } else if (mathValue === 0) {
                            label = '0';
                        } else {
                            label = `${displayValue}i`;
                        }
                    } else {
                        // For real functions or when showing plain values
                        label = displayValue;
                    }

                    g.fillText(label, originX + 15, y);
                }
            }

            // Negative side for imaginary axis
            for (let y = offsetY - scale * step; y >= 0; y -= scale * step) {
                if (Math.abs(y - originY) < 5) continue; // Skip origin

                const gridSteps = -Math.round((y - originY) / scale);
                const mathValue = gridSteps * unitScale;

                if (y >= 20 && y <= c.height - 20 && Math.abs(mathValue) <= 20 * unitScale) {
                    const displayValue = unitScale < 1 ? mathValue.toFixed(1) : mathValue.toString();

                    // Determine if we should show 'i' suffix based on the current function and plane
                    const shouldShowI = imagLabel.includes('Im(') || imagLabel.includes('i');
                    let label;

                    if (shouldShowI) {
                        // For complex functions, show 'i' suffix
                        if (mathValue === 1) {
                            label = 'i';
                        } else if (mathValue === -1) {
                            label = '-i';
                        } else if (mathValue === 0) {
                            label = '0';
                        } else {
                            label = `${displayValue}i`;
                        }
                    } else {
                        // For real functions or when showing plain values
                        label = displayValue;
                    }

                    g.fillText(label, originX + 15, y);
                }
            }

            // Draw axis labels
            g.font = 'bold 14px Arial';
            g.fillStyle = textColor;
            g.textAlign = 'right';
            g.textBaseline = 'bottom';
            g.fillText(realLabel, c.width - 10, originY - 10);
            g.textAlign = 'left';
            g.textBaseline = 'top';
            g.fillText(imagLabel, originX + 10, 10);
        }

        // Smooth rendering optimization
        let renderQueued = false;
        let lastRenderTime = 0;
        const RENDER_THROTTLE = 16; // ~60fps

        function queueRender() {
            if (!renderQueued) {
                renderQueued = true;
                requestAnimationFrame(() => {
                    const now = Date.now();
                    if (now - lastRenderTime >= RENDER_THROTTLE) {
                        redrawAll();
                        lastRenderTime = now;
                    }
                    renderQueued = false;
                });
            }
        }

        // Use queued rendering for better performance
        function optimizedRedraw() {
            queueRender();
        }

        function redrawAll() {
            drawGrid('domain');
            drawGrid('codomain');

            // Draw chessboard if active
            if (chessboard && toolSelect.value === 'chessboard') {
                drawChessboard();
            }

            strokes.forEach((s, i) => {
                const alpha = i < strokes.length - MAX_STROKES ? 0.2 : 1;
                const baseColor = `hsla(${s.hue},70%,${isDarkMode ? 60 : 40}%,${alpha})`;
                ['domain', 'codomain'].forEach(key => {
                    const pts = key === s.canvas ? s.pts : s.imagePts, g = ctx[key];

                    // Skip drawing if no points
                    if (!pts || pts.length === 0) return;

                    g.strokeStyle = baseColor;
                    g.lineWidth = 2;

                    // Optimize stroke drawing during zoom operations
                    if (window.isZooming && pts.length > 20) {
                        // During zoom, simplify complex strokes by sampling every nth point
                        const simplifiedPts = pts.filter((_, idx) => idx % 2 === 0);
                        drawShape(g, simplifiedPts, s.mode);
                    } else {
                        // Normal drawing with all points
                        drawShape(g, pts, s.mode);
                    }
                });
            });

            dots.forEach(d => {
                ['domain', 'codomain'].forEach((key, idx) => {
                    const g = ctx[key];
                    const lab = (idx === 0 ? d.label.dom : userFn(d.label.dom));
                    const p = toCanvas(lab, key);
                    g.fillStyle = isDarkMode ? 'yellow' : '#ff6600';
                    g.beginPath();
                    g.arc(p.x, p.y, 5, 0, 2 * Math.PI);
                    g.fill();
                    g.fillStyle = isDarkMode ? '#ffffff' : '#000000';

                    // Use correct notation for dot labels
                    const labels = window.currentLabels || {
                        inputRealLabel: 'Re(z)', inputImagLabel: 'Im(z)',
                        outputRealLabel: 'Re(w)', outputImagLabel: 'Im(w)'
                    };

                    // Use actual mathematical coordinates (not grid-snapped)
                    const precision = 3; // Always use 3 decimal places for dots
                    let labelText;

                    if (idx === 0) {
                        // Domain (input) dot - use the actual mathematical coordinates
                        const realPart = labels.inputRealLabel.replace(/[()]/g, '');
                        const imagPart = labels.inputImagLabel.replace(/[()]/g, '');
                        labelText = `${realPart}=${lab.re.toFixed(precision)}, ${imagPart}=${lab.im.toFixed(precision)}`;
                    } else {
                        // Codomain (output) dot - use the actual transformed mathematical coordinates
                        const realPart = labels.outputRealLabel.replace(/[()]/g, '');
                        const imagPart = labels.outputImagLabel.replace(/[()]/g, '');
                        labelText = `${realPart}=${lab.re.toFixed(precision)}, ${imagPart}=${lab.im.toFixed(precision)}`;
                    }

                    g.fillText(labelText, p.x + 6, p.y - 6);
                });
            });

            // Draw texts with transformed font shapes
            texts.forEach((t, index) => {
                ['domain', 'codomain'].forEach(key => {
                    const g = ctx[key];
                    const isOriginal = key === t.canvas;

                    if (isOriginal) {
                        // Check if corners have been modified from original rectangle
                        const originalHalfWidth = t.width / 2;
                        const originalHalfHeight = t.height / 2;
                        const originalCorners = [
                            { x: t.x - originalHalfWidth, y: t.y - originalHalfHeight },
                            { x: t.x + originalHalfWidth, y: t.y - originalHalfHeight },
                            { x: t.x + originalHalfWidth, y: t.y + originalHalfHeight },
                            { x: t.x - originalHalfWidth, y: t.y + originalHalfHeight }
                        ];

                        // Check if corners are still in original positions (within small tolerance)
                        const tolerance = 2;
                        const isRectangular = t.corners.every((corner, i) =>
                            Math.abs(corner.x - originalCorners[i].x) < tolerance &&
                            Math.abs(corner.y - originalCorners[i].y) < tolerance
                        );

                        // Check if text has been transformed (has transformedPoints on other canvas)
                        const hasTransformation = t.transformedPoints && t.transformedPoints.length > 0;

                        if (isRectangular && !hasTransformation) {
                            // Draw original text normally only if not warped AND not transformed on other canvas
                            g.font = `${t.fontSize}px ${t.fontFamily}`;
                            // Use appropriate color based on theme if text color is default
                            const textColor = t.color === '#ffffff' ? (isDarkMode ? '#ffffff' : '#000000') : t.color;
                            g.fillStyle = textColor;
                            g.textAlign = 'center';
                            g.textBaseline = 'middle';
                            g.fillText(t.text, t.x, t.y);
                        } else {
                            // Draw warped text using point-based approach (no blur, just stretch)
                            const pointsToRender = t.warpedPoints || [];
                            pointsToRender.forEach(pt => {
                                if (isFinite(pt.x) && isFinite(pt.y)) {
                                    g.fillStyle = pt.color;
                                    const size = pt.size || 3;
                                    g.beginPath();
                                    g.arc(pt.x, pt.y, size, 0, 2 * Math.PI);
                                    g.fill();
                                }
                            });
                        }

                        // Draw border around text when in text mode
                        if (toolSelect.value === 'text') {
                            const minX = Math.min(t.corners[0].x, t.corners[1].x, t.corners[2].x, t.corners[3].x);
                            const maxX = Math.max(t.corners[0].x, t.corners[1].x, t.corners[2].x, t.corners[3].x);
                            const minY = Math.min(t.corners[0].y, t.corners[1].y, t.corners[2].y, t.corners[3].y);
                            const maxY = Math.max(t.corners[0].y, t.corners[1].y, t.corners[2].y, t.corners[3].y);

                            g.strokeStyle = '#00ff88';
                            g.lineWidth = 2;
                            g.strokeRect(minX - 2, minY - 2, maxX - minX + 4, maxY - minY + 4);

                            // Draw corners when in text mode
                            t.corners.forEach((corner, i) => {
                                g.fillStyle = '#ff3333';
                                g.beginPath();
                                g.arc(corner.x, corner.y, 6, 0, 2 * Math.PI);
                                g.fill();
                                g.strokeStyle = '#fff';
                                g.lineWidth = 2;
                                g.stroke();
                            });
                        }
                    } else if (t.transformedPoints) {
                        // Draw transformed text without gaps
                        drawTransformedText(g, t);
                    }
                });
            });

            // Draw images
            images.forEach((img, index) => {
                ['domain', 'codomain'].forEach(key => {
                    const g = ctx[key];
                    const isOriginal = key === img.canvas;

                    if (isOriginal) {
                        // Check if corners form a proper rectangle (not warped)
                        const [tl, tr, br, bl] = img.corners;

                        // Check if it's still a rectangle (parallel sides, right angles)
                        const isRectangular = (
                            Math.abs((tr.x - tl.x) - (br.x - bl.x)) < 5 && // Top and bottom sides parallel
                            Math.abs((bl.y - tl.y) - (br.y - tr.y)) < 5 && // Left and right sides parallel
                            Math.abs((tr.y - tl.y) - (br.y - bl.y)) < 5 && // Top and bottom same height difference
                            Math.abs((bl.x - tl.x) - (br.x - tr.x)) < 5    // Left and right same width difference
                        );

                        if (isRectangular) {
                            // Calculate bounding box of corners to fit image properly
                            const minX = Math.min(tl.x, tr.x, br.x, bl.x);
                            const maxX = Math.max(tl.x, tr.x, br.x, bl.x);
                            const minY = Math.min(tl.y, tr.y, br.y, bl.y);
                            const maxY = Math.max(tl.y, tr.y, br.y, bl.y);

                            // Draw image to fit the rectangular bounds
                            g.drawImage(img.element, minX, minY, maxX - minX, maxY - minY);
                        } else {
                            // Draw warped image using proper stretching/warping (no dots)
                            drawWarpedImage(g, img);
                        }

                        // Draw border around image when in image mode
                        if (toolSelect.value === 'image') {
                            g.strokeStyle = '#00ff88';
                            g.lineWidth = 2;

                            // Draw border following the actual corners (warped shape)
                            g.beginPath();
                            g.moveTo(img.corners[0].x, img.corners[0].y); // top-left
                            g.lineTo(img.corners[1].x, img.corners[1].y); // top-right
                            g.lineTo(img.corners[2].x, img.corners[2].y); // bottom-right
                            g.lineTo(img.corners[3].x, img.corners[3].y); // bottom-left
                            g.closePath();
                            g.stroke();

                            // Draw corners when in image mode
                            img.corners.forEach((corner, i) => {
                                g.fillStyle = '#ff3333';
                                g.beginPath();
                                g.arc(corner.x, corner.y, 6, 0, 2 * Math.PI);
                                g.fill();
                                g.strokeStyle = '#fff';
                                g.lineWidth = 2;
                                g.stroke();
                            });
                        }
                    } else if (img.transformedPoints) {
                        // Draw transformed image without gaps
                        drawTransformedImage(g, img);
                    }
                });
            });
        }

        function drawShape(g, pts, mode) { if (!pts || pts.length < 2) return; g.beginPath(); g.moveTo(pts[0].x, pts[0].y); pts.forEach((p, i) => { if (i > 0) g.lineTo(p.x, p.y); }); if (!['freehand', 'line', 'sine', 'spiral', 'dot', 'etch'].includes(mode)) g.closePath(); g.stroke(); }

        function computePts(tool, A, B) {
            // Apply snap to grid to endpoints if enabled
            let startPt = A, endPt = B;
            if (snapToGrid && ['line', 'circle', 'polygon', 'star'].includes(tool)) {
                startPt = snapToGridPoint(A.x, A.y, activeCanvas);
                endPt = snapToGridPoint(B.x, B.y, activeCanvas);
            }

            const pts = [], dx = endPt.x - startPt.x, dy = endPt.y - startPt.y;

            switch (tool) {
                case 'line':
                    for (let t = 0; t <= 1; t += 0.01) {
                        pts.push({ x: startPt.x + dx * t, y: startPt.y + dy * t });
                    }
                    break;
                case 'circle': {
                    const cx = (startPt.x + endPt.x) / 2, cy = (startPt.y + endPt.y) / 2, r = Math.hypot(dx, dy) / 2;
                    for (let a = 0; a < 2 * Math.PI; a += 0.02) {
                        pts.push({ x: cx + Math.cos(a) * r, y: cy + Math.sin(a) * r });
                    }
                    pts.push(pts[0]);
                } break;
                case 'polygon': {
                    const sides = Math.max(3, parseInt(paramInput.value) || 5), ang0 = Math.atan2(dy, dx), rad = Math.hypot(dx, dy), verts = [];
                    for (let i = 0; i < sides; i++) {
                        const ang = ang0 + 2 * Math.PI * i / sides;
                        verts.push({ x: startPt.x + Math.cos(ang) * rad, y: startPt.y + Math.sin(ang) * rad });
                    }
                    verts.push(verts[0]);
                    const sp = 50;
                    for (let k = 0; k < verts.length - 1; k++) {
                        const P = verts[k], Q = verts[k + 1], sx = Q.x - P.x, sy = Q.y - P.y;
                        for (let t = 0; t <= 1; t += 1 / sp) {
                            pts.push({ x: P.x + sx * t, y: P.y + sy * t });
                        }
                    }
                } break;
                case 'sine': {
                    const w = Math.hypot(dx, dy), ux = dx / w, uy = dy / w, max = Math.hypot(canvases[activeCanvas].width, canvases[activeCanvas].height);
                    for (let t = 0; t < max; t += 2) {
                        const cx = startPt.x + ux * t, cy = startPt.y + uy * t, amp = w / 4, ph = 2 * Math.PI * t / w;
                        pts.push({ x: cx - uy * amp * Math.sin(ph), y: cy + ux * amp * Math.sin(ph) });
                    }
                } break;
                case 'spiral': {
                    const turns = Math.max(1, parseInt(paramInput.value) || 3);
                    const scale = Math.hypot(dx, dy) / 100; // Use distance for scale only
                    const b = Math.log(1.618) / (Math.PI * 0.5);
                    const maxT = turns * 2 * Math.PI;

                    for (let th = 0; th <= maxT; th += 0.05) {
                        const r = scale * Math.exp(b * th);
                        // Start spiral at angle 0 and always center at point A
                        pts.push({ x: startPt.x + Math.cos(th) * r, y: startPt.y + Math.sin(th) * r });
                    }
                } break;
                case 'star': {
                    const n = Math.max(3, parseInt(paramInput.value) || 5), rad = Math.hypot(dx, dy), a0 = Math.atan2(dy, dx), verts = [];

                    if (n === 6) {
                        // Special case for 6-pointed star (Star of David)
                        const outerRad = rad;
                        const innerRad = rad * 0.58; // Better ratio for symmetry

                        for (let i = 0; i < 12; i++) {
                            const angle = a0 + (i * Math.PI / 6);
                            const r = (i % 2 === 0) ? outerRad : innerRad;
                            verts.push({ x: startPt.x + Math.cos(angle) * r, y: startPt.y + Math.sin(angle) * r });
                        }
                        verts.push(verts[0]);
                    } else if (n % 2 === 0 && n !== 6) {
                        const h = n / 2, f = [], s = [];
                        for (let i = 0; i < h; i++) {
                            const a = a0 + 2 * Math.PI * i / h;
                            f.push({ x: startPt.x + Math.cos(a) * rad, y: startPt.y + Math.sin(a) * rad });
                        }
                        for (let i = 0; i < h; i++) {
                            const a = a0 + Math.PI / n + 2 * Math.PI * i / h;
                            s.push({ x: startPt.x + Math.cos(a) * rad, y: startPt.y + Math.sin(a) * rad });
                        }
                        verts.push(...f, ...s, f[0]);
                    } else {
                        const skip = Math.floor(n / 2);
                        for (let i = 0; i < n; i++) {
                            const idx = (i * skip) % n, a = a0 + 2 * Math.PI * idx / n;
                            verts.push({ x: startPt.x + Math.cos(a) * rad, y: startPt.y + Math.sin(a) * rad });
                        }
                        verts.push(verts[0]);
                    }

                    const sp = 50;
                    for (let k = 0; k < verts.length - 1; k++) {
                        const P = verts[k], Q = verts[k + 1], sx = Q.x - P.x, sy = Q.y - P.y;
                        for (let t = 0; t <= 1; t += 1 / sp) {
                            pts.push({ x: P.x + sx * t, y: P.y + sy * t });
                        }
                    }
                } break;
            }
            return pts;
        }

        function startDraw(evt) {
            // Prevent default to avoid conflicts with touch handling
            evt.preventDefault();

            if (continuousToggle.checked) prevInv = null;
            let p = getPos(evt, activeCanvas);

            // Apply snap to grid if enabled for drawing operations
            if (snapToGrid && ['line', 'circle', 'polygon', 'dot', 'star'].includes(toolSelect.value)) {
                p = snapToGridPoint(p.x, p.y, activeCanvas);
            }

            // Handle text corner dragging
            if (toolSelect.value === 'text') {
                const textCorner = findTextCornerAt(p.x, p.y, activeCanvas);
                if (textCorner) {
                    isDraggingTextCorner = true;
                    draggedTextIndex = textCorner.textIndex;
                    draggedTextCornerIndex = textCorner.cornerIndex;
                    return;
                }

                // Handle text dragging (whole text)
                const textIndex = getTextAt(p.x, p.y, activeCanvas);
                if (textIndex !== -1) {
                    isDraggingText = true;
                    draggedTextIndex = textIndex;
                    const text = texts[textIndex];
                    textDragOffset = { x: p.x - text.x, y: p.y - text.y };
                    return;
                }
            }

            // Handle image corner dragging
            if (toolSelect.value === 'image') {
                const imageCorner = findImageCornerAt(p.x, p.y, activeCanvas);
                if (imageCorner) {
                    isDraggingImageCorner = true;
                    draggedImageIndex = imageCorner.imageIndex;
                    draggedImageCornerIndex = imageCorner.cornerIndex;
                    return;
                }

                // Handle image dragging (whole image)
                const imageIndex = getImageAt(p.x, p.y, activeCanvas);
                if (imageIndex !== -1) {
                    isDraggingImage = true;
                    draggedImageIndex = imageIndex;
                    const img = images[imageIndex];
                    imageDragOffset = { x: p.x - img.x, y: p.y - img.y };
                    return;
                }
            }

            // Handle chessboard corner dragging
            if (toolSelect.value === 'chessboard' && activeCanvas === 'domain') {
                const cornerIndex = getCornerAt(p.x, p.y);
                if (cornerIndex !== -1) {
                    isDraggingCorner = true;
                    dragCornerIndex = cornerIndex;
                    return;
                }

                // Check if clicking inside chessboard for dragging whole board
                if (isInsideChessboard(p.x, p.y)) {
                    isDraggingChessboard = true;
                    const center = getChessboardCenter();
                    chessboardDragOffset = { x: p.x - center.x, y: p.y - center.y };
                    return;
                }
            }

            if (toolSelect.value === 'dot') {
                const z = toComplex(p.x, p.y, activeCanvas);
                dots.push({ canvas: activeCanvas, label: { dom: z } });
                redrawAll();
                return;
            }

            if (toolSelect.value === 'text') {
                const text = textInput.value || 'Hello';
                const fontSize = parseInt(fontSizeInput.value) || 24;
                const color = fontColorInput.value || '#ffffff';
                const fontFamily = fontFamilyInput.value || 'Arial';
                addTransformableText(text, p.x, p.y, activeCanvas, fontSize, color, fontFamily);
                return;
            }

            if (toolSelect.value === 'image') {
                // Image mode is handled by drag and drop
                return;
            }

            isDrawing = true;
            startPt = p;
            currentPts = [p];
        }
        function moveDraw(evt) {
            // Prevent default to avoid conflicts with touch handling  
            if (evt.type.startsWith('touch')) {
                evt.preventDefault();
            }

            let p = getPos(evt, activeCanvas);

            // Apply snap to grid if enabled for drawing operations
            if (snapToGrid && ['line', 'circle', 'polygon', 'dot', 'star'].includes(toolSelect.value)) {
                p = snapToGridPoint(p.x, p.y, activeCanvas);
            }

            // Handle text corner dragging with different modes
            if (isDraggingTextCorner && draggedTextIndex !== -1 && draggedTextCornerIndex !== -1) {
                evt.preventDefault();
                const text = texts[draggedTextIndex];

                if (isShiftPressed) {
                    // SHIFT: Free warping - move only the selected corner
                    text.corners[draggedTextCornerIndex] = p;
                } else if (isCtrlPressed) {
                    // CTRL: Proportional scaling from center
                    const center = { x: text.x, y: text.y };
                    const cornerIndex = draggedTextCornerIndex;
                    const dx = p.x - center.x;
                    const dy = p.y - center.y;
                    const distance = Math.hypot(dx, dy);
                    const originalCorner = text.corners[cornerIndex];
                    const originalDistance = Math.hypot(originalCorner.x - center.x, originalCorner.y - center.y);
                    const scale = distance / originalDistance;

                    // Scale all corners proportionally from center
                    text.corners.forEach((corner, i) => {
                        const relX = corner.x - center.x;
                        const relY = corner.y - center.y;
                        text.corners[i] = {
                            x: center.x + relX * scale,
                            y: center.y + relY * scale
                        };
                    });
                } else {
                    // Normal: Resize maintaining rectangle shape
                    const center = { x: text.x, y: text.y };
                    const cornerIndex = draggedTextCornerIndex;
                    const dx = Math.abs(p.x - center.x) * 2;
                    const dy = Math.abs(p.y - center.y) * 2;

                    // Update all corners to maintain rectangle
                    text.corners = [
                        { x: center.x - dx / 2, y: center.y - dy / 2 }, // top-left
                        { x: center.x + dx / 2, y: center.y - dy / 2 }, // top-right
                        { x: center.x + dx / 2, y: center.y + dy / 2 }, // bottom-right
                        { x: center.x - dx / 2, y: center.y + dy / 2 }  // bottom-left
                    ];
                }

                updateTextFromCorners(draggedTextIndex);
                redrawAll();
                return;
            }

            // Handle text dragging
            if (isDraggingText && draggedTextIndex !== -1) {
                evt.preventDefault();
                const text = texts[draggedTextIndex];
                const dx = p.x - textDragOffset.x - text.x;
                const dy = p.y - textDragOffset.y - text.y;

                // Move all corners by the same offset
                text.corners.forEach(corner => {
                    corner.x += dx;
                    corner.y += dy;
                });

                text.x = p.x - textDragOffset.x;
                text.y = p.y - textDragOffset.y;
                text.canvas = activeCanvas; // Allow moving between canvases
                updateTextTransformations();
                redrawAll();
                return;
            }

            // Handle image corner dragging with different modes
            if (isDraggingImageCorner && draggedImageIndex !== -1 && draggedImageCornerIndex !== -1) {
                evt.preventDefault();
                const img = images[draggedImageIndex];

                if (isShiftPressed) {
                    // SHIFT: Free warping - move only the selected corner
                    img.corners[draggedImageCornerIndex] = p;
                } else if (isCtrlPressed) {
                    // CTRL: Proportional scaling from center
                    const center = { x: img.x, y: img.y };
                    const cornerIndex = draggedImageCornerIndex;
                    const dx = p.x - center.x;
                    const dy = p.y - center.y;
                    const distance = Math.hypot(dx, dy);
                    const originalCorner = img.corners[cornerIndex];
                    const originalDistance = Math.hypot(originalCorner.x - center.x, originalCorner.y - center.y);
                    const scale = distance / originalDistance;

                    // Scale all corners proportionally from center
                    img.corners.forEach((corner, i) => {
                        const relX = corner.x - center.x;
                        const relY = corner.y - center.y;
                        img.corners[i] = {
                            x: center.x + relX * scale,
                            y: center.y + relY * scale
                        };
                    });
                } else {
                    // Normal: Resize maintaining rectangle shape
                    const center = { x: img.x, y: img.y };
                    const cornerIndex = draggedImageCornerIndex;
                    const dx = Math.abs(p.x - center.x) * 2;
                    const dy = Math.abs(p.y - center.y) * 2;

                    // Update all corners to maintain rectangle
                    img.corners = [
                        { x: center.x - dx / 2, y: center.y - dy / 2 }, // top-left
                        { x: center.x + dx / 2, y: center.y - dy / 2 }, // top-right
                        { x: center.x + dx / 2, y: center.y + dy / 2 }, // bottom-right
                        { x: center.x - dx / 2, y: center.y + dy / 2 }  // bottom-left
                    ];
                }

                updateImageFromCorners(draggedImageIndex);
                redrawAll();
                return;
            }

            // Handle image dragging
            if (isDraggingImage && draggedImageIndex !== -1) {
                evt.preventDefault();
                const img = images[draggedImageIndex];
                const dx = p.x - imageDragOffset.x - img.x;
                const dy = p.y - imageDragOffset.y - img.y;

                // Move all corners by the same offset
                img.corners.forEach(corner => {
                    corner.x += dx;
                    corner.y += dy;
                });

                img.x = p.x - imageDragOffset.x;
                img.y = p.y - imageDragOffset.y;
                img.canvas = activeCanvas; // Allow moving between canvases
                updateImageTransformation(img);
                redrawAll();
                return;
            }

            // Handle chessboard corner dragging
            if (isDraggingCorner && dragCornerIndex !== -1 && activeCanvas === 'domain') {
                evt.preventDefault();
                chessboard.corners[dragCornerIndex] = p;
                redrawAll();
                return;
            }

            // Handle chessboard whole board dragging
            if (isDraggingChessboard && activeCanvas === 'domain') {
                evt.preventDefault();
                const newCenter = { x: p.x - chessboardDragOffset.x, y: p.y - chessboardDragOffset.y };
                moveChessboard(newCenter);
                redrawAll();
                return;
            }

            if (!isDrawing) return;
            const tool = toolSelect.value;

            if (tool === 'freehand') {
                evt.preventDefault();
                currentPts.push(p);
                redrawAll();
                ['domain', 'codomain'].forEach(key => {
                    const pts = key === activeCanvas ? currentPts : currentPts.map(pt => toCanvas(tool === 'freehand' ? (activeCanvas === 'domain' ? userFn(toComplex(pt.x, pt.y, activeCanvas)) : invFn(toComplex(pt.x, pt.y, activeCanvas))) : toComplex(pt.x, pt.y, activeCanvas), key));
                    ctx[key].strokeStyle = isDarkMode ? '#fff' : '#000';
                    ctx[key].lineWidth = 2;
                    drawShape(ctx[key], pts, 'freehand');
                });
            } else if (tool !== 'dot' && tool !== 'chessboard') {
                evt.preventDefault();
                const pts = computePts(tool, startPt, p);
                const img = pts.map(pt => toCanvas(activeCanvas === 'domain' ? userFn(toComplex(pt.x, pt.y, activeCanvas)) : invFn(toComplex(pt.x, pt.y, activeCanvas)), activeCanvas === 'domain' ? 'codomain' : 'domain'));
                redrawAll();
                ['domain', 'codomain'].forEach(key => {
                    const pts2 = key === activeCanvas ? pts : img;
                    ctx[key].strokeStyle = isDarkMode ? '#fff' : '#000';
                    ctx[key].lineWidth = 2;
                    drawShape(ctx[key], pts2, tool);
                });
            }
        }
        function endDraw(evt) {
            // Handle text corner dragging end
            if (isDraggingTextCorner) {
                isDraggingTextCorner = false;
                draggedTextIndex = -1;
                draggedTextCornerIndex = -1;
                return;
            }

            // Handle text dragging end
            if (isDraggingText) {
                isDraggingText = false;
                draggedTextIndex = -1;
                return;
            }

            // Handle image corner dragging end
            if (isDraggingImageCorner) {
                isDraggingImageCorner = false;
                draggedImageIndex = -1;
                draggedImageCornerIndex = -1;
                return;
            }

            // Handle image dragging end
            if (isDraggingImage) {
                isDraggingImage = false;
                draggedImageIndex = -1;
                return;
            }

            // Handle chessboard corner dragging end
            if (isDraggingCorner) {
                isDraggingCorner = false;
                dragCornerIndex = -1;
                return;
            }

            // Handle chessboard whole board dragging end
            if (isDraggingChessboard) {
                isDraggingChessboard = false;
                return;
            }

            if (!isDrawing) return;
            evt.preventDefault();
            isDrawing = false;
            const tool = toolSelect.value;
            if (tool === 'dot' || tool === 'chessboard') return;
            const ePt = getPos(evt, activeCanvas);
            const pts = tool === 'freehand' ? currentPts : computePts(tool, startPt, ePt);
            const img = pts.map(pt => toCanvas(activeCanvas === 'domain' ? userFn(toComplex(pt.x, pt.y, activeCanvas)) : invFn(toComplex(pt.x, pt.y, activeCanvas)), activeCanvas === 'domain' ? 'codomain' : 'domain'));
            strokes.push({ canvas: activeCanvas, mode: tool, pts: pts, imagePts: img, hue: Math.random() * 360 });
            if (strokes.length > MAX_STROKES) strokes.shift();
            redrawAll();
        }
        function getPos(evt, key) {
            const canvas = canvases[key];
            let clientX, clientY;

            if (evt.touches && evt.touches.length > 0) {
                clientX = evt.touches[0].clientX;
                clientY = evt.touches[0].clientY;
            } else if (evt.changedTouches && evt.changedTouches.length > 0) {
                clientX = evt.changedTouches[0].clientX;
                clientY = evt.changedTouches[0].clientY;
            } else {
                clientX = evt.clientX;
                clientY = evt.clientY;
            }

            // Get canvas bounding rectangle
            const rect = canvas.getBoundingClientRect();

            // Calculate position relative to canvas top-left corner
            // Use Math.round to ensure pixel-perfect positioning
            const x = Math.round(clientX - rect.left);
            const y = Math.round(clientY - rect.top);

            return { x, y };
        }

        // Helper function to check if point is near a corner
        function isNearCorner(point, corner, threshold = 10) {
            const dx = point.x - corner.x;
            const dy = point.y - corner.y;
            return Math.sqrt(dx * dx + dy * dy) < threshold;
        }

        // Helper function to find text corner at point
        function findTextCornerAt(x, y, canvas) {
            for (let i = 0; i < texts.length; i++) {
                const text = texts[i];
                if (text.canvas !== canvas) continue;

                for (let j = 0; j < text.corners.length; j++) {
                    if (isNearCorner({ x, y }, text.corners[j], 12)) {
                        return { textIndex: i, cornerIndex: j };
                    }
                }
            }
            return null;
        }

        // Helper function to find image corner at point
        function findImageCornerAt(x, y, canvas) {
            for (let i = 0; i < images.length; i++) {
                const img = images[i];
                if (img.canvas !== canvas) continue;

                for (let j = 0; j < img.corners.length; j++) {
                    if (isNearCorner({ x, y }, img.corners[j], 12)) {
                        return { imageIndex: i, cornerIndex: j };
                    }
                }
            }
            return null;
        }

        // Helper function to get image at point
        function getImageAt(x, y, canvas) {
            for (let i = images.length - 1; i >= 0; i--) {
                const img = images[i];
                if (img.canvas === canvas) {
                    // Check if point is inside image bounds (simplified bounding box check)
                    const minX = Math.min(img.corners[0].x, img.corners[1].x, img.corners[2].x, img.corners[3].x);
                    const maxX = Math.max(img.corners[0].x, img.corners[1].x, img.corners[2].x, img.corners[3].x);
                    const minY = Math.min(img.corners[0].y, img.corners[1].y, img.corners[2].y, img.corners[3].y);
                    const maxY = Math.max(img.corners[0].y, img.corners[1].y, img.corners[2].y, img.corners[3].y);

                    if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
                        return i;
                    }
                }
            }
            return -1;
        }

        // Helper function to get text at point
        function getTextAt(x, y, canvas) {
            for (let i = texts.length - 1; i >= 0; i--) {
                const text = texts[i];
                if (text.canvas === canvas) {
                    // Check if point is inside text bounds (simplified bounding box check)
                    const minX = Math.min(text.corners[0].x, text.corners[1].x, text.corners[2].x, text.corners[3].x);
                    const maxX = Math.max(text.corners[0].x, text.corners[1].x, text.corners[2].x, text.corners[3].x);
                    const minY = Math.min(text.corners[0].y, text.corners[1].y, text.corners[2].y, text.corners[3].y);
                    const maxY = Math.max(text.corners[0].y, text.corners[1].y, text.corners[2].y, text.corners[3].y);

                    if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
                        return i;
                    }
                }
            }
            return -1;
        }

        // Touch gesture handling functions
        function getTouchDistance(touches) {
            if (touches.length < 2) return 0;
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function getTouchCenter(touches) {
            if (touches.length === 1) {
                return { x: touches[0].clientX, y: touches[0].clientY };
            }
            if (touches.length >= 2) {
                return {
                    x: (touches[0].clientX + touches[1].clientX) / 2,
                    y: (touches[0].clientY + touches[1].clientY) / 2
                };
            }
            return { x: 0, y: 0 };
        }

        function handleTouchStart(evt) {
            const touches = evt.touches;
            touchStartTime = Date.now();

            // Add haptic feedback on supported devices
            if (navigator.vibrate && touches.length === 1) {
                navigator.vibrate(10);
            }

            if (touches.length === 1) {
                // Single touch - could be drawing or start of gesture
                const touch = touches[0];
                const canvas = evt.target;
                activeCanvas = canvas === canvases.domain ? 'domain' : 'codomain';

                touchGestureMode = 'draw';
                lastPanPosition = { x: touch.clientX, y: touch.clientY };

                // Start drawing if appropriate
                startDraw(evt);

            } else if (touches.length === 2) {
                // Two fingers - pan/zoom gesture
                evt.preventDefault();

                // Haptic feedback for gesture start
                if (navigator.vibrate) {
                    navigator.vibrate(15);
                }

                touchStartDistance = getTouchDistance(touches);
                touchStartCenter = getTouchCenter(touches);
                lastPanPosition = touchStartCenter;

                // Start in undetermined mode - will decide based on movement
                touchGestureMode = 'undetermined';

                // End any current drawing
                if (isDrawing) {
                    endDraw(evt);
                }
            }

            isTouching = true;
        } function handleTouchMove(evt) {
            if (!isTouching) return;

            const touches = evt.touches;

            if (touches.length === 1 && touchGestureMode === 'draw') {
                // Single finger drawing
                moveDraw(evt);

            } else if (touches.length === 2) {
                // Two finger gesture - determine type if not already decided
                evt.preventDefault();

                const currentDistance = getTouchDistance(touches);
                const currentCenter = getTouchCenter(touches);

                // Calculate changes from start
                const distanceChange = Math.abs(currentDistance - touchStartDistance);
                const centerChangeX = currentCenter.x - touchStartCenter.x;
                const centerChangeY = currentCenter.y - touchStartCenter.y;
                const totalCenterChange = Math.hypot(centerChangeX, centerChangeY);

                // Simplified gesture detection - more reliable for phones
                // Simplified touch handling - only support panning with 2 fingers
                if (touchGestureMode === 'undetermined') {
                    const minMovement = 8; // Threshold for initial movement detection

                    if (totalCenterChange > minMovement) {
                        // Only support panning - no zoom
                        touchGestureMode = 'pan';
                        if (navigator.vibrate) navigator.vibrate(10);
                    }
                }

                // Execute pan gesture
                if (touchGestureMode === 'pan') {
                    // Two-finger pan
                    if (lastPanPosition) {
                        const deltaX = currentCenter.x - lastPanPosition.x;
                        const deltaY = currentCenter.y - lastPanPosition.y;

                        // Lower threshold for more responsive panning
                        if (Math.hypot(deltaX, deltaY) > 1) {
                            // Apply pan to both canvases directly
                            origin.domain.x += deltaX;
                            origin.domain.y += deltaY;
                            origin.codomain.x += deltaX;
                            origin.codomain.y += deltaY;

                            // Update transformations and redraw for real-time feedback
                            updateAllTransformations();
                            redrawAll();
                        }
                    }
                    // Always update position for smoother panning
                    lastPanPosition = currentCenter;
                }
            }
        }

        function handleTouchEnd(evt) {
            const touches = evt.touches;

            if (touches.length === 0) {
                // All fingers lifted
                if (touchGestureMode === 'draw') {
                    endDraw(evt);
                }

                // Clean up touch state
                isTouching = false;
                touchGestureMode = 'none';
                lastPanPosition = null;
                touchStartDistance = 0;

            } else if (touches.length === 1 && (touchGestureMode === 'pan' || touchGestureMode === 'undetermined')) {
                // Went from 2 fingers to 1 - switch to draw mode
                touchGestureMode = 'draw';
                lastPanPosition = { x: touches[0].clientX, y: touches[0].clientY };

                // Start drawing with remaining finger
                const touch = touches[0];
                const canvas = evt.target;
                activeCanvas = canvas === canvases.domain ? 'domain' : 'codomain';
                startDraw(evt);
            }
        }

        // Separate touch and mouse event handling to avoid conflicts

        // Mouse events
        ['mousedown'].forEach(e => {
            canvases.domain.addEventListener(e, () => activeCanvas = 'domain');
            canvases.codomain.addEventListener(e, () => activeCanvas = 'codomain');
            canvases.domain.addEventListener(e, startDraw);
            canvases.codomain.addEventListener(e, startDraw);
        });

        ['mousemove'].forEach(e => {
            canvases.domain.addEventListener(e, moveDraw);
            canvases.codomain.addEventListener(e, moveDraw);
        });

        ['mouseup', 'mouseleave'].forEach(e => window.addEventListener(e, endDraw));

        // Touch events - handle with gesture support
        ['touchstart'].forEach(e => {
            canvases.domain.addEventListener(e, handleTouchStart, { passive: false });
            canvases.codomain.addEventListener(e, handleTouchStart, { passive: false });
        });

        ['touchmove'].forEach(e => {
            canvases.domain.addEventListener(e, handleTouchMove, { passive: false });
            canvases.codomain.addEventListener(e, handleTouchMove, { passive: false });
        });

        ['touchend', 'touchcancel'].forEach(e => {
            window.addEventListener(e, handleTouchEnd, { passive: false });
        });
        canvases.domain.addEventListener('mousemove', evt => {
            const p = getPos(evt, 'domain');

            // Calculate the precise mathematical coordinate (not snapped to grid)
            const zoomVal = parseFloat(document.getElementById('zoomSlider').value) || 1;
            let unitScale;
            if (zoomVal < 0.5) {
                unitScale = 10;
            } else if (zoomVal < 1) {
                unitScale = 5;
            } else if (zoomVal <= 1.5) {
                unitScale = 1;
            } else if (zoomVal <= 2.5) {
                unitScale = 0.5;
            } else {
                unitScale = 0.2;
            }

            const originX = origin.domain.x;
            const originY = origin.domain.y;

            // Calculate precise coordinates (not rounded to grid)
            const preciseX = ((p.x - originX) / scale) * unitScale;
            const preciseY = -((p.y - originY) / scale) * unitScale;

            if (!isFinite(preciseX) || !isFinite(preciseY)) { tooltip.style.display = 'none'; return; }
            tooltip.style.display = 'block';

            // Use current labels for tooltip
            const labels = window.currentLabels || { inputRealLabel: 'Re(z)', inputImagLabel: 'Im(z)' };
            const realPart = labels.inputRealLabel.replace(/[()]/g, '');
            const imagPart = labels.inputImagLabel.replace(/[()]/g, '');

            // Show precise coordinates with 3 decimal places
            tooltip.textContent = `${realPart}=${preciseX.toFixed(3)}, ${imagPart}=${preciseY.toFixed(3)}`;

            tooltip.style.left = evt.clientX + 10 + 'px';
            tooltip.style.top = evt.clientY + 10 + 'px';

            // Change cursor based on what's under the mouse
            let cursor = 'crosshair';

            if (toolSelect.value === 'text') {
                if (findTextCornerAt(p.x, p.y, 'domain')) {
                    cursor = 'nw-resize';
                } else if (getTextAt(p.x, p.y, 'domain') !== -1) {
                    cursor = 'move';
                }
            } else if (toolSelect.value === 'image') {
                if (findImageCornerAt(p.x, p.y, 'domain')) {
                    cursor = 'nw-resize';
                } else if (getImageAt(p.x, p.y, 'domain') !== -1) {
                    cursor = 'move';
                }
            } else {
                // Use simple arrow cursor for precise positioning
                cursor = 'default';
            }

            canvases.domain.style.cursor = cursor;
        });
        canvases.codomain.addEventListener('mousemove', evt => {
            const p = getPos(evt, 'codomain');

            // Calculate the precise mathematical coordinate (not snapped to grid)
            const zoomVal = parseFloat(document.getElementById('zoomSlider').value) || 1;
            let unitScale;
            if (zoomVal < 0.5) {
                unitScale = 10;
            } else if (zoomVal < 1) {
                unitScale = 5;
            } else if (zoomVal <= 1.5) {
                unitScale = 1;
            } else if (zoomVal <= 2.5) {
                unitScale = 0.5;
            } else {
                unitScale = 0.2;
            }

            const originX = origin.codomain.x;
            const originY = origin.codomain.y;

            // Calculate precise coordinates (not rounded to grid)
            const preciseX = ((p.x - originX) / scale) * unitScale;
            const preciseY = -((p.y - originY) / scale) * unitScale;

            if (!isFinite(preciseX) || !isFinite(preciseY)) { tooltip.style.display = 'none'; return; }
            tooltip.style.display = 'block';

            // Use current labels for tooltip
            const labels = window.currentLabels || { outputRealLabel: 'Re(w)', outputImagLabel: 'Im(w)' };
            const realPart = labels.outputRealLabel.replace(/[()]/g, '');
            const imagPart = labels.outputImagLabel.replace(/[()]/g, '');

            // Show precise coordinates with 3 decimal places
            tooltip.textContent = `${realPart}=${preciseX.toFixed(3)}, ${imagPart}=${preciseY.toFixed(3)}`;

            tooltip.style.left = evt.clientX + 10 + 'px';
            tooltip.style.top = evt.clientY + 10 + 'px';

            // Change cursor based on what's under the mouse
            let cursor = 'crosshair';

            if (toolSelect.value === 'text') {
                if (findTextCornerAt(p.x, p.y, 'codomain')) {
                    cursor = 'nw-resize';
                } else if (getTextAt(p.x, p.y, 'codomain') !== -1) {
                    cursor = 'move';
                }
            } else if (toolSelect.value === 'image') {
                if (findImageCornerAt(p.x, p.y, 'codomain')) {
                    cursor = 'nw-resize';
                } else if (getImageAt(p.x, p.y, 'codomain') !== -1) {
                    cursor = 'move';
                }
            } else {
                // Use simple arrow cursor for precise positioning
                cursor = 'default';
            }

            canvases.codomain.style.cursor = cursor;
        });
        canvases.domain.addEventListener('mouseleave', () => tooltip.style.display = 'none'); canvases.codomain.addEventListener('mouseleave', () => tooltip.style.display = 'none');
        clearBtn.addEventListener('click', () => { strokes.length = 0; dots.length = 0; texts.length = 0; images.length = 0; redrawAll(); });

        // Undo functionality - removes the most recent item
        undoBtn.addEventListener('click', () => {
            if (strokes.length > 0) {
                strokes.pop();
            } else if (dots.length > 0) {
                dots.pop();
            } else if (texts.length > 0) {
                texts.pop();
            } else if (images.length > 0) {
                images.pop();
            }
            redrawAll();
        });

        // Reset/Center functionality - centers the grid on both canvases
        function resetGridCenter() {
            // Reset origins to canvas centers
            origin.domain = { x: canvases.domain.width / 2, y: canvases.domain.height / 2 };
            origin.codomain = { x: canvases.codomain.width / 2, y: canvases.codomain.height / 2 };

            // Update chessboard if it exists
            if (chessboard && toolSelect.value === 'chessboard') {
                updateChessboardScale();
            }

            // Update all transformations and redraw
            updateAllTransformations();
            redrawAll();
        }

        resetBtn.addEventListener('click', resetGridCenter);
        resetBtn2.addEventListener('click', resetGridCenter);
        snapToGridToggle.addEventListener('change', (e) => {
            snapToGrid = e.target.checked;
        });

        // Track modifier keys for different drag modes
        window.addEventListener('keydown', (evt) => {
            // Handle Ctrl+Z for undo
            if (evt.ctrlKey && evt.key === 'z') {
                evt.preventDefault(); // Prevent browser default undo
                // Trigger undo function
                if (strokes.length > 0) {
                    strokes.pop();
                } else if (dots.length > 0) {
                    dots.pop();
                } else if (texts.length > 0) {
                    texts.pop();
                } else if (images.length > 0) {
                    images.pop();
                }
                redrawAll();
                return;
            }

            if (evt.key === 'Shift') isShiftPressed = true;
            if (evt.key === 'Control') isCtrlPressed = true;
        });

        window.addEventListener('keyup', (evt) => {
            if (evt.key === 'Shift') isShiftPressed = false;
            if (evt.key === 'Control') isCtrlPressed = false;
        });

        resize();

        // Initialize mobile features
        initMobileFeatures();

        // Initialize labels
        updateLabels();

        // Initialize zoom value display
        const zoomValueElement = document.querySelector('.zoom-value');
        if (zoomValueElement) {
            zoomValueElement.textContent = '1.0x';
        }

        // Etch-a-Sketch state
        let etchActive = false;
        let etchCursor = { re: 0, im: 0 };

        // Handle mode switch for etch-a-sketch
        toolSelect.addEventListener('change', () => {
            etchActive = (toolSelect.value === 'etch');
            paramLabel.style.display = (['spiral', 'star', 'polygon'].includes(toolSelect.value)) ? 'inline-block' : 'none';
            if (etchActive) {
                etchCursor = { re: 0, im: 0 };
            }
            if (toolSelect.value === 'chessboard') {
                initChessboard();
            }
        });

        // WASD controls for etch-a-sketch and arrow keys for panning
        window.addEventListener('keydown', evt => {
            let direction = null;

            // Map keys to directions
            switch (evt.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    direction = 'up';
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    direction = 'down';
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    direction = 'left';
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    direction = 'right';
                    break;
                default:
                    return;
            }

            if (direction) {
                evt.preventDefault();
                handleDirectionalInput(direction);
                return;
            }
        });

        // Integer Grid functions (formerly chessboard)
        function initChessboard() {
            // Create a grid that uses the actual origin position (no snapping)
            const gridSize = 5; // Units from center
            const centerX = origin.domain.x; // Use actual origin
            const centerY = origin.domain.y;

            // Calculate grid extent in canvas coordinates (no snapping)
            const extent = gridSize * scale;

            chessboard = {
                gridSize: gridSize, // Number of units from center
                corners: [
                    { x: centerX - extent, y: centerY - extent }, // top-left (-5, +5i)
                    { x: centerX + extent, y: centerY - extent }, // top-right (+5, +5i)
                    { x: centerX + extent, y: centerY + extent }, // bottom-right (+5, -5i)
                    { x: centerX - extent, y: centerY + extent }  // bottom-left (-5, -5i)
                ]
            };
            redrawAll();
        }

        function bilinearInterpolate(corners, u, v) {
            // Bilinear interpolation between four corners
            const x1 = (1 - u) * (1 - v) * corners[0].x + u * (1 - v) * corners[1].x +
                u * v * corners[2].x + (1 - u) * v * corners[3].x;
            const y1 = (1 - u) * (1 - v) * corners[0].y + u * (1 - v) * corners[1].y +
                u * v * corners[2].y + (1 - u) * v * corners[3].y;
            return { x: x1, y: y1 };
        }

        function drawChessboard() {
            if (!chessboard) return;

            const g = ctx.domain;
            const gc = ctx.codomain;
            const gridSize = chessboard.gridSize || 5;
            const numLines = gridSize * 2 + 1; // Lines from -gridSize to +gridSize

            // Draw grid lines with integer alignment
            for (let i = 0; i < numLines; i++) {
                // Horizontal lines (constant imaginary part)
                const hPts = [];
                const hImagePts = [];
                for (let k = 0; k <= 80; k++) { // High resolution for smooth curves
                    const u = k / 80; // 0 to 1 across the grid
                    const v = i / (numLines - 1); // 0 to 1 down the grid
                    const pt = bilinearInterpolate(chessboard.corners, u, v);
                    hPts.push(pt);
                    const z = toComplex(pt.x, pt.y, 'domain');
                    const w = userFn(z);
                    if (isFinite(w.re) && isFinite(w.im)) {
                        hImagePts.push(toCanvas(w, 'codomain'));
                    }
                }

                // Draw horizontal line on domain
                g.strokeStyle = i === gridSize ? '#ffffff' : '#00ff88'; // Center line in white
                g.lineWidth = i === gridSize ? 3 : 2;
                g.beginPath();
                if (hPts.length > 0) {
                    g.moveTo(hPts[0].x, hPts[0].y);
                    hPts.forEach(p => g.lineTo(p.x, p.y));
                    g.stroke();
                }

                // Draw transformed horizontal line on codomain
                if (hImagePts.length > 1) {
                    gc.strokeStyle = i === gridSize ? '#ffffff' : '#00ff88';
                    gc.lineWidth = i === gridSize ? 3 : 2;
                    gc.beginPath();
                    gc.moveTo(hImagePts[0].x, hImagePts[0].y);
                    hImagePts.forEach(p => {
                        if (isFinite(p.x) && isFinite(p.y)) {
                            gc.lineTo(p.x, p.y);
                        }
                    });
                    gc.stroke();
                }

                // Vertical lines (constant real part)
                const vPts = [];
                const vImagePts = [];
                for (let k = 0; k <= 80; k++) { // High resolution for smooth curves
                    const u = i / (numLines - 1); // 0 to 1 across the grid
                    const v = k / 80; // 0 to 1 down the grid
                    const pt = bilinearInterpolate(chessboard.corners, u, v);
                    vPts.push(pt);
                    const z = toComplex(pt.x, pt.y, 'domain');
                    const w = userFn(z);
                    if (isFinite(w.re) && isFinite(w.im)) {
                        vImagePts.push(toCanvas(w, 'codomain'));
                    }
                }

                // Draw vertical line on domain
                g.strokeStyle = i === gridSize ? '#ffffff' : '#00ff88'; // Center line in white
                g.lineWidth = i === gridSize ? 3 : 2;
                g.beginPath();
                if (vPts.length > 0) {
                    g.moveTo(vPts[0].x, vPts[0].y);
                    vPts.forEach(p => g.lineTo(p.x, p.y));
                    g.stroke();
                }

                // Draw transformed vertical line on codomain
                if (vImagePts.length > 1) {
                    gc.strokeStyle = i === gridSize ? '#ffffff' : '#00ff88';
                    gc.lineWidth = i === gridSize ? 3 : 2;
                    gc.beginPath();
                    gc.moveTo(vImagePts[0].x, vImagePts[0].y);
                    vImagePts.forEach(p => {
                        if (isFinite(p.x) && isFinite(p.y)) {
                            gc.lineTo(p.x, p.y);
                        }
                    });
                    gc.stroke();
                }
            }

            // Draw corner handles
            chessboard.corners.forEach((corner, i) => {
                g.fillStyle = '#ff3333';
                g.beginPath();
                g.arc(corner.x, corner.y, 8, 0, 2 * Math.PI);
                g.fill();
                g.strokeStyle = '#fff';
                g.lineWidth = 2;
                g.stroke();
            });

            // Draw grid coordinate labels on corners
            g.fillStyle = '#ffffff';
            g.font = '14px Arial';
            g.textAlign = 'center';
            g.textBaseline = 'middle';

            const labels = [
                `${-gridSize} + ${gridSize}i`, // top-left
                `${gridSize} + ${gridSize}i`,  // top-right  
                `${gridSize} - ${gridSize}i`,  // bottom-right
                `${-gridSize} - ${gridSize}i`  // bottom-left
            ];

            chessboard.corners.forEach((corner, i) => {
                const offsetX = i === 0 || i === 3 ? -60 : 60; // Left corners: left offset, right corners: right offset
                const offsetY = i === 0 || i === 1 ? -20 : 20;  // Top corners: up offset, bottom corners: down offset
                g.fillText(labels[i], corner.x + offsetX, corner.y + offsetY);
            });
        }

        function getCornerAt(x, y) {
            if (!chessboard) return -1;
            for (let i = 0; i < chessboard.corners.length; i++) {
                const corner = chessboard.corners[i];
                const dist = Math.hypot(x - corner.x, y - corner.y);
                if (dist < 15) return i;
            }
            return -1;
        }

        function getChessboardCenter() {
            if (!chessboard) return { x: 0, y: 0 };
            const corners = chessboard.corners;
            return {
                x: (corners[0].x + corners[1].x + corners[2].x + corners[3].x) / 4,
                y: (corners[0].y + corners[1].y + corners[2].y + corners[3].y) / 4
            };
        }

        function moveChessboard(newCenter) {
            if (!chessboard) return;

            // Use new center position directly (no snapping)
            const centerX = newCenter.x;
            const centerY = newCenter.y;

            const gridSize = chessboard.gridSize || 5;
            const extent = gridSize * scale;

            // Update corners without snapping
            chessboard.corners = [
                { x: centerX - extent, y: centerY - extent },
                { x: centerX + extent, y: centerY - extent },
                { x: centerX + extent, y: centerY + extent },
                { x: centerX - extent, y: centerY + extent }
            ];
        }

        function isInsideChessboard(x, y) {
            if (!chessboard) return false;
            // Simple bounding box check
            const corners = chessboard.corners;
            const minX = Math.min(...corners.map(c => c.x));
            const maxX = Math.max(...corners.map(c => c.x));
            const minY = Math.min(...corners.map(c => c.y));
            const maxY = Math.max(...corners.map(c => c.y));

            return x >= minX && x <= maxX && y >= minY && y <= maxY;
        }

        // Text and Image functions
        function addTransformableText(text, x, y, canvas, fontSize, color, fontFamily = 'Arial') {
            // Create a temporary canvas to measure text dimensions
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.font = `${fontSize}px ${fontFamily}`;
            const metrics = tempCtx.measureText(text);
            const textWidth = metrics.width;
            const textHeight = fontSize; // Approximate height

            // Center the text at the click position
            const halfWidth = textWidth / 2;
            const halfHeight = textHeight / 2;

            texts.push({
                text: text,
                canvas: canvas,
                transformedPoints: [], // Will be filled by updateTextTransformations
                fontSize: fontSize,
                fontFamily: fontFamily,
                color: color,
                x: x,
                y: y,
                width: textWidth,
                height: textHeight,
                corners: [
                    { x: x - halfWidth, y: y - halfHeight }, // Top-left
                    { x: x + halfWidth, y: y - halfHeight }, // Top-right
                    { x: x + halfWidth, y: y + halfHeight }, // Bottom-right
                    { x: x - halfWidth, y: y + halfHeight } // Bottom-left
                ]
            });

            updateTextTransformations();
            redrawAll();
        }

        function updateTextTransformations() {
            texts.forEach(t => {
                // Create a smaller temporary canvas to sample the text
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');

                // Set reasonable canvas size based on text
                tempCtx.font = `${t.fontSize}px ${t.fontFamily}`;
                const textMetrics = tempCtx.measureText(t.text);
                const textWidth = Math.ceil(textMetrics.width + 20);
                const textHeight = Math.ceil(t.fontSize * 1.5);

                tempCanvas.width = textWidth;
                tempCanvas.height = textHeight;

                // Render the text to sample from
                tempCtx.font = `${t.fontSize}px ${t.fontFamily}`;
                tempCtx.fillStyle = t.color;
                tempCtx.textAlign = 'center';
                tempCtx.textBaseline = 'middle';
                tempCtx.fillText(t.text, textWidth / 2, textHeight / 2);

                // Get image data
                const sourceImageData = tempCtx.getImageData(0, 0, textWidth, textHeight);
                const sourceData = sourceImageData.data;

                // Sample with adaptive density and quality optimization
                const transformedPoints = [];
                const warpedPoints = []; // For the original canvas when warped

                // Calculate optimal sample step based on content size and quality
                const contentSize = textWidth * textHeight;
                const quality = getQualityLevel(contentSize);
                const baseSampleStep = Math.max(PERFORMANCE_SETTINGS.MIN_SAMPLE_STEP, Math.floor(t.fontSize / 20));
                const sampleStep = Math.max(1, baseSampleStep / quality.density);

                // For transformed points (right side), use 20x higher resolution for ultra-smooth text
                const transformedSampleStep = Math.max(1, sampleStep / 20);

                for (let py = 0; py < textHeight; py += sampleStep) {
                    for (let px = 0; px < textWidth; px += sampleStep) {
                        const pixelIndex = (py * textWidth + px) * 4;
                        const alpha = sourceData[pixelIndex + 3];

                        if (alpha > 25) {
                            // Convert from temp canvas to normalized coordinates (0-1)
                            const u = px / textWidth;
                            const v = py / textHeight;

                            // Use bilinear interpolation with corners to get world position
                            const worldPos = bilinearInterpolate(t.corners, u, v);

                            // Store warped points for original canvas
                            const r = sourceData[pixelIndex];
                            const g = sourceData[pixelIndex + 1];
                            const b = sourceData[pixelIndex + 2];

                            warpedPoints.push({
                                x: worldPos.x,
                                y: worldPos.y,
                                color: `rgba(${r},${g},${b},0.6)`, // Semi-transparent for overlapping
                                size: sampleStep * 4.0 // Much larger circles to fill gaps
                            });
                        }
                    }
                }

                // Generate higher resolution points for transformation (3x resolution)
                for (let py = 0; py < textHeight; py += transformedSampleStep) {
                    for (let px = 0; px < textWidth; px += transformedSampleStep) {
                        const pixelIndex = (py * textWidth + px) * 4;
                        const alpha = sourceData[pixelIndex + 3];

                        if (alpha > 25) {
                            // Convert from temp canvas to normalized coordinates (0-1)
                            const u = px / textWidth;
                            const v = py / textHeight;

                            // Use bilinear interpolation with corners to get world position
                            const worldPos = bilinearInterpolate(t.corners, u, v);

                            const r = sourceData[pixelIndex];
                            const g = sourceData[pixelIndex + 1];
                            const b = sourceData[pixelIndex + 2];

                            // Transform this point for the other canvas
                            const z = toComplex(worldPos.x, worldPos.y, t.canvas);
                            const w = t.canvas === 'domain' ? userFn(z) : invFn(z);

                            if (isFinite(w.re) && isFinite(w.im)) {
                                const transformedPt = toCanvas(w, t.canvas === 'domain' ? 'codomain' : 'domain');

                                if (isFinite(transformedPt.x) && isFinite(transformedPt.y)) {
                                    transformedPoints.push({
                                        x: transformedPt.x,
                                        y: transformedPt.y,
                                        color: `rgba(${r},${g},${b},0.95)`, // Very high alpha for 20x resolution compensation
                                        size: transformedSampleStep * 2.5 // Bigger circles for smoother appearance
                                    });
                                }
                            }
                        }
                    }
                }

                t.transformedPoints = transformedPoints;
                t.warpedPoints = warpedPoints;
            });
        }

        // Performance caching for transformations
        const transformationCache = new Map();

        function getCacheKey(obj, type) {
            if (type === 'text') {
                return `text_${obj.text}_${obj.fontSize}_${obj.corners.map(c => `${c.x},${c.y}`).join('_')}_${functionSelect.value}`;
            } else if (type === 'image') {
                return `image_${obj.width}_${obj.height}_${obj.corners.map(c => `${c.x},${c.y}`).join('_')}_${functionSelect.value}`;
            }
            return null;
        }

        function clearTransformationCache() {
            transformationCache.clear();
        }

        // Clear cache when function changes
        functionSelect.addEventListener('change', clearTransformationCache);

        function showImageInstructions() {
            showNotification('Image Mode: Drag & drop files OR paste from clipboard (Ctrl+V)! Images transform mathematically!', activeCanvas);
        }

        function drawTransformedImage(g, img) {
            if (!img.transformedPoints || img.transformedPoints.length === 0) return;

            // Get canvas bounds for culling
            const canvasWidth = g.canvas.width;
            const canvasHeight = g.canvas.height;

            // Batch points by color for better performance
            const pointsByColor = new Map();

            img.transformedPoints.forEach(pt => {
                if (isFinite(pt.x) && isFinite(pt.y)) {
                    // Cull points outside visible area (with small margin for large points)
                    const margin = pt.size || 5;
                    if (pt.x < -margin || pt.x > canvasWidth + margin ||
                        pt.y < -margin || pt.y > canvasHeight + margin) {
                        return; // Skip this point
                    }

                    const color = pt.color;
                    if (!pointsByColor.has(color)) {
                        pointsByColor.set(color, []);
                    }
                    pointsByColor.get(color).push(pt);
                }
            });

            // Draw points batched by color
            pointsByColor.forEach((points, color) => {
                g.fillStyle = color;
                points.forEach(pt => {
                    const size = pt.size || 1;
                    g.beginPath();
                    g.arc(pt.x, pt.y, size, 0, 2 * Math.PI);
                    g.fill();
                });
            });
        }

        function drawTransformedText(g, text) {
            if (!text.transformedPoints || text.transformedPoints.length === 0) return;

            // Get canvas bounds for culling
            const canvasWidth = g.canvas.width;
            const canvasHeight = g.canvas.height;

            // Batch points by color for better performance
            const pointsByColor = new Map();

            text.transformedPoints.forEach(pt => {
                if (isFinite(pt.x) && isFinite(pt.y)) {
                    // Cull points outside visible area (with small margin for large points)
                    const margin = pt.size || 5;
                    if (pt.x < -margin || pt.x > canvasWidth + margin ||
                        pt.y < -margin || pt.y > canvasHeight + margin) {
                        return; // Skip this point
                    }

                    const color = pt.color;
                    if (!pointsByColor.has(color)) {
                        pointsByColor.set(color, []);
                    }
                    pointsByColor.get(color).push(pt);
                }
            });

            // Draw points batched by color
            pointsByColor.forEach((points, color) => {
                g.fillStyle = color;
                points.forEach(pt => {
                    const size = pt.size || 1;
                    g.beginPath();
                    g.arc(pt.x, pt.y, size, 0, 2 * Math.PI);
                    g.fill();
                });
            });
        }

        function handleImageDrop(evt, canvas) {
            evt.preventDefault();
            isDragOver = false;

            const files = evt.dataTransfer.files;
            if (files.length === 0) return;

            const file = files[0];
            if (!file.type.startsWith('image/')) {
                alert('Please drop an image file.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function (e) {
                const img = new Image();
                img.onload = function () {
                    const dropPos = getPos(evt, canvas);
                    addImage(img, dropPos.x, dropPos.y, canvas);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function addImage(imgElement, x, y, canvas) {
            // Place image at click location with reasonable default size
            // Use a moderate default size that maintains aspect ratio
            const canvasSize = Math.min(canvases[canvas].width, canvases[canvas].height);
            const defaultSize = Math.min(canvasSize * 0.25, 200); // Slightly larger default size

            const aspectRatio = imgElement.width / imgElement.height;
            let width, height;

            if (aspectRatio > 1) {
                // Landscape orientation
                width = defaultSize;
                height = width / aspectRatio;
            } else {
                // Portrait or square orientation
                height = defaultSize;
                width = height * aspectRatio;
            }

            const halfWidth = width / 2;
            const halfHeight = height / 2;

            const img = {
                element: imgElement,
                canvas: canvas,
                x: x,
                y: y,
                width: width,
                height: height,
                originalWidth: imgElement.width,
                originalHeight: imgElement.height,
                scaleFactor: width / imgElement.width, // Track scaling for performance optimization
                transformedPoints: [],
                warpedPoints: [],
                corners: [
                    { x: x - halfWidth, y: y - halfHeight }, // Top-left
                    { x: x + halfWidth, y: y - halfHeight }, // Top-right
                    { x: x + halfWidth, y: y + halfHeight }, // Bottom-right
                    { x: x - halfWidth, y: y + halfHeight } // Bottom-left
                ]
            };

            updateImageTransformation(img);
            images.push(img);
            redrawAll();
        }

        function updateImageTransformation(img) {
            // Use forward mapping like text for better performance
            const transformedPoints = [];
            const warpedPoints = []; // For the original canvas when warped

            // Create a temporary canvas to sample from the original image
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = img.element.width;
            tempCanvas.height = img.element.height;
            tempCtx.drawImage(img.element, 0, 0);
            const sourceImageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const sourceData = sourceImageData.data;

            // Sample with adaptive density for scalable quality
            const contentSize = img.width * img.height;
            const quality = getQualityLevel(contentSize);
            const baseSampleStep = Math.max(PERFORMANCE_SETTINGS.MIN_SAMPLE_STEP, 2);
            const sampleStep = Math.max(1, baseSampleStep / quality.density);

            // For transformed points (right side), use 20x higher resolution for ultra-smooth images
            const transformedSampleStep = Math.max(1, sampleStep / 20);

            // Generate points for warped display on original canvas
            for (let y = 0; y < img.height; y += sampleStep) {
                for (let x = 0; x < img.width; x += sampleStep) {
                    // Convert to normalized coordinates (0-1)
                    const u = x / img.width;
                    const v = y / img.height;

                    // Use bilinear interpolation with corners to get world position
                    const worldPos = bilinearInterpolate(img.corners, u, v);

                    // Sample the original image
                    const imgX = Math.floor(x * img.element.width / img.width);
                    const imgY = Math.floor(y * img.element.height / img.height);

                    if (imgX >= 0 && imgX < img.element.width && imgY >= 0 && imgY < img.element.height) {
                        const pixelIndex = (imgY * img.element.width + imgX) * 4;
                        const alpha = sourceData[pixelIndex + 3];

                        if (alpha > 25) { // Only process non-transparent pixels
                            const r = sourceData[pixelIndex];
                            const g = sourceData[pixelIndex + 1];
                            const b = sourceData[pixelIndex + 2];

                            // Store warped points for original canvas
                            warpedPoints.push({
                                x: worldPos.x,
                                y: worldPos.y,
                                color: `rgba(${r},${g},${b},0.6)`, // Semi-transparent for overlapping
                                size: sampleStep * 4.0 // Much larger circles to fill gaps
                            });
                        }
                    }
                }
            }

            // Generate higher resolution points for transformation (20x resolution)
            for (let y = 0; y < img.height; y += transformedSampleStep) {
                for (let x = 0; x < img.width; x += transformedSampleStep) {
                    // Convert to normalized coordinates (0-1)
                    const u = x / img.width;
                    const v = y / img.height;

                    // Use bilinear interpolation with corners to get world position
                    const worldPos = bilinearInterpolate(img.corners, u, v);

                    // Sample the original image
                    const imgX = Math.floor(x * img.element.width / img.width);
                    const imgY = Math.floor(y * img.element.height / img.height);

                    if (imgX >= 0 && imgX < img.element.width && imgY >= 0 && imgY < img.element.height) {
                        const pixelIndex = (imgY * img.element.width + imgX) * 4;
                        const alpha = sourceData[pixelIndex + 3];

                        if (alpha > 25) { // Only process non-transparent pixels
                            const r = sourceData[pixelIndex];
                            const g = sourceData[pixelIndex + 1];
                            const b = sourceData[pixelIndex + 2];

                            // Transform this point for the other canvas with higher resolution
                            const z = toComplex(worldPos.x, worldPos.y, img.canvas);
                            const w = img.canvas === 'domain' ? userFn(z) : invFn(z);

                            if (isFinite(w.re) && isFinite(w.im)) {
                                const transformedPt = toCanvas(w, img.canvas === 'domain' ? 'codomain' : 'domain');

                                if (isFinite(transformedPt.x) && isFinite(transformedPt.y)) {
                                    transformedPoints.push({
                                        x: transformedPt.x,
                                        y: transformedPt.y,
                                        color: `rgba(${r},${g},${b},0.95)`, // Very high alpha for 20x resolution compensation
                                        size: transformedSampleStep * 2.5 // Bigger circles for smoother appearance
                                    });
                                }
                            }
                        }
                    }
                }
            }

            img.transformedPoints = transformedPoints;
            img.warpedPoints = warpedPoints;
        }

        function bilinearSample(imageData, width, height, x, y) {
            // Clamp coordinates
            x = Math.max(0, Math.min(width - 1, x));
            y = Math.max(0, Math.min(height - 1, y));

            const x1 = Math.floor(x);
            const y1 = Math.floor(y);
            const x2 = Math.min(x1 + 1, width - 1);
            const y2 = Math.min(y1 + 1, height - 1);

            const fx = x - x1;
            const fy = y - y1;

            // Get the four surrounding pixels
            const getPixel = (px, py) => {
                const index = (py * width + px) * 4;
                return {
                    r: imageData[index],
                    g: imageData[index + 1],
                    b: imageData[index + 2],
                    a: imageData[index + 3]
                };
            };

            const p1 = getPixel(x1, y1);
            const p2 = getPixel(x2, y1);
            const p3 = getPixel(x1, y2);
            const p4 = getPixel(x2, y2);

            // Bilinear interpolation
            const interpolate = (v1, v2, v3, v4) => {
                const top = v1 * (1 - fx) + v2 * fx;
                const bottom = v3 * (1 - fx) + v4 * fx;
                return top * (1 - fy) + bottom * fy;
            };

            return {
                r: Math.round(interpolate(p1.r, p2.r, p3.r, p4.r)),
                g: Math.round(interpolate(p1.g, p2.g, p3.g, p4.g)),
                b: Math.round(interpolate(p1.b, p2.b, p3.b, p4.b)),
                a: Math.round(interpolate(p1.a, p2.a, p3.a, p4.a))
            };
        }

        // Set up drag and drop for images
        ['domain', 'codomain'].forEach(key => {
            const canvas = canvases[key];

            canvas.addEventListener('dragover', (evt) => {
                evt.preventDefault();
                isDragOver = true;
                canvas.style.backgroundColor = '#333';
            });

            canvas.addEventListener('dragleave', (evt) => {
                isDragOver = false;
                canvas.style.backgroundColor = '#222';
            });

            canvas.addEventListener('drop', (evt) => {
                handleImageDrop(evt, key);
                canvas.style.backgroundColor = '#222';
            });
        });

        // Set up clipboard paste for images
        let lastMousePos = { domain: { x: 0, y: 0 }, codomain: { x: 0, y: 0 } };

        // Track mouse position for paste location
        ['domain', 'codomain'].forEach(key => {
            canvases[key].addEventListener('mousemove', (evt) => {
                const pos = getPos(evt, key);
                lastMousePos[key] = pos;
            });
        });

        // Handle clipboard paste
        window.addEventListener('paste', async (evt) => {
            // Only handle paste when in image mode
            if (toolSelect.value !== 'image') return;

            evt.preventDefault();
            const clipboardItems = evt.clipboardData.items;

            for (let item of clipboardItems) {
                if (item.type.startsWith('image/')) {
                    const file = item.getAsFile();
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = function (e) {
                            const img = new Image();
                            img.onload = function () {
                                // Determine which canvas to paste to based on cursor position or default to domain
                                let targetCanvas = 'domain';

                                // Check if mouse is over codomain canvas
                                const codomainRect = canvases.codomain.getBoundingClientRect();
                                const domainRect = canvases.domain.getBoundingClientRect();

                                // Use the canvas where the mouse was last active, or default to domain
                                if (lastMousePos.codomain.x > 0 && activeCanvas === 'codomain') {
                                    targetCanvas = 'codomain';
                                }

                                const pos = lastMousePos[targetCanvas];
                                addImage(img, pos.x || canvases[targetCanvas].width / 2, pos.y || canvases[targetCanvas].height / 2, targetCanvas);

                                // Show a brief notification
                                showNotification('Image pasted from clipboard!', targetCanvas);
                            };
                            img.src = e.target.result;
                        };
                        reader.readAsDataURL(file);
                    }
                    break; // Only handle the first image
                }
            }
        });

        // Show notification function
        function showNotification(message, canvas = 'domain') {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(76, 205, 196, 0.9);
                color: white;
                padding: 10px 20px;
                border-radius: 5px;
                font-size: 14px;
                z-index: 100;
                pointer-events: none;
                transition: opacity 0.3s;
            `;
            notification.textContent = message;

            const container = canvases[canvas].parentElement;
            container.appendChild(notification);

            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => container.removeChild(notification), 300);
            }, 2000);
        }

        // Update text dimensions and transformations based on corners
        function updateTextFromCorners(textIndex) {
            const text = texts[textIndex];
            const corners = text.corners;

            // Calculate new bounds from corners
            const minX = Math.min(corners[0].x, corners[1].x, corners[2].x, corners[3].x);
            const maxX = Math.max(corners[0].x, corners[1].x, corners[2].x, corners[3].x);
            const minY = Math.min(corners[0].y, corners[1].y, corners[2].y, corners[3].y);
            const maxY = Math.max(corners[0].y, corners[1].y, corners[2].y, corners[3].y);

            // Update position to center of bounds
            text.x = (minX + maxX) / 2;
            text.y = (minY + maxY) / 2;
            text.width = maxX - minX;
            text.height = maxY - minY;

            updateTextTransformations();
        }

        function updateImageFromCorners(imageIndex) {
            const image = images[imageIndex];
            const corners = image.corners;

            // Calculate new bounds from corners
            const minX = Math.min(corners[0].x, corners[1].x, corners[2].x, corners[3].x);
            const maxX = Math.max(corners[0].x, corners[1].x, corners[2].x, corners[3].x);
            const minY = Math.min(corners[0].y, corners[1].y, corners[2].y, corners[3].y);
            const maxY = Math.max(corners[0].y, corners[1].y, corners[2].y, corners[3].y);

            // Update position to center of bounds
            image.x = (minX + maxX) / 2;
            image.y = (minY + maxY) / 2;
            image.width = maxX - minX;
            image.height = maxY - minY;

            updateImageTransformation(image);
        }

        function drawWarpedImage(g, img) {
            // Draw warped image using proper stretching and warping
            // Map the entire image to fit within the corner boundaries

            // Save the current context state
            g.save();

            try {
                // Get the four corners of the warped image
                const [tl, tr, br, bl] = img.corners;

                // Adaptive grid resolution based on zoom level and image size for performance
                // Lower resolution during zoom operations or for smaller images
                const imageArea = img.width * img.height;
                const zoomFactor = scale / baseScale;

                let gridResolution;
                if (imageArea < 10000 || zoomFactor < 0.5) {
                    gridResolution = 8; // Low resolution for small images or when zoomed out
                } else if (zoomFactor > 2) {
                    gridResolution = 20; // High resolution when zoomed in
                } else {
                    gridResolution = 12; // Medium resolution for normal viewing
                }

                // Draw the image in segments using transforms
                // Divide the image into a grid and transform each segment
                for (let i = 0; i < gridResolution; i++) {
                    for (let j = 0; j < gridResolution; j++) {
                        const u1 = i / gridResolution;
                        const v1 = j / gridResolution;
                        const u2 = (i + 1) / gridResolution;
                        const v2 = (j + 1) / gridResolution;

                        // Source rectangle in original image (map entire image to corners)
                        const sx = u1 * img.element.width;
                        const sy = v1 * img.element.height;
                        const sw = (u2 - u1) * img.element.width;
                        const sh = (v2 - v1) * img.element.height;

                        // Destination quadrilateral corners using bilinear interpolation
                        const destTL = bilinearInterpolate(img.corners, u1, v1);
                        const destTR = bilinearInterpolate(img.corners, u2, v1);
                        const destBR = bilinearInterpolate(img.corners, u2, v2);
                        const destBL = bilinearInterpolate(img.corners, u1, v2);

                        // Early exit if segment is completely outside visible area
                        const minX = Math.min(destTL.x, destTR.x, destBR.x, destBL.x);
                        const maxX = Math.max(destTL.x, destTR.x, destBR.x, destBL.x);
                        const minY = Math.min(destTL.y, destTR.y, destBR.y, destBL.y);
                        const maxY = Math.max(destTL.y, destTR.y, destBR.y, destBL.y);

                        if (maxX < 0 || minX > g.canvas.width || maxY < 0 || minY > g.canvas.height) {
                            continue; // Skip segments outside visible area
                        }

                        // Draw this segment as a transformed rectangle approximation
                        g.save();

                        // Set up clipping path for this segment
                        g.beginPath();
                        g.moveTo(destTL.x, destTL.y);
                        g.lineTo(destTR.x, destTR.y);
                        g.lineTo(destBR.x, destBR.y);
                        g.lineTo(destBL.x, destBL.y);
                        g.closePath();
                        g.clip();

                        // Calculate approximate transform for this segment
                        const centerDest = {
                            x: (destTL.x + destTR.x + destBR.x + destBL.x) / 4,
                            y: (destTL.y + destTR.y + destBR.y + destBL.y) / 4
                        };

                        // Calculate scale factors based on segment size
                        const destWidth = Math.abs(destTR.x - destTL.x);
                        const destHeight = Math.abs(destBL.y - destTL.y);
                        const scaleX = destWidth / sw;
                        const scaleY = destHeight / sh;

                        // Apply transformation
                        g.translate(centerDest.x, centerDest.y);
                        g.scale(scaleX, scaleY);

                        // Draw the image segment
                        g.drawImage(
                            img.element,
                            sx, sy, sw, sh,
                            -sw / 2, -sh / 2, sw, sh
                        );

                        g.restore();
                    }
                }
            } catch (error) {
                // Fallback: draw the image to fit the corner bounds
                console.warn('Image warping failed, using fallback:', error);

                // Calculate bounding box of corners
                const minX = Math.min(img.corners[0].x, img.corners[1].x, img.corners[2].x, img.corners[3].x);
                const maxX = Math.max(img.corners[0].x, img.corners[1].x, img.corners[2].x, img.corners[3].x);
                const minY = Math.min(img.corners[0].y, img.corners[1].y, img.corners[2].y, img.corners[3].y);
                const maxY = Math.max(img.corners[0].y, img.corners[1].y, img.corners[2].y, img.corners[3].y);

                // Draw image to fit bounding box
                g.drawImage(img.element, minX, minY, maxX - minX, maxY - minY);
            }

            // Restore the context state
            g.restore();
        }

        // Directional button controls for both panning and etch-a-sketch
        function setupDirectionalControls() {
            document.querySelectorAll('.direction-btn').forEach(btn => {
                // Skip center reset buttons - they have their own handlers
                if (btn.classList.contains('center')) {
                    return;
                }

                // Mouse click
                btn.addEventListener('click', (evt) => {
                    evt.preventDefault();
                    const direction = evt.target.dataset.direction;
                    handleDirectionalInput(direction);
                });

                // Touch handling for mobile with better feedback
                btn.addEventListener('touchstart', (evt) => {
                    evt.preventDefault();
                    const direction = evt.target.dataset.direction;

                    // Haptic feedback
                    if (navigator.vibrate) {
                        navigator.vibrate(10);
                    }

                    handleDirectionalInput(direction);

                    // Visual feedback
                    evt.target.style.background = 'rgba(255, 255, 255, 0.4)';
                    evt.target.style.transform = 'scale(0.95)';
                }, { passive: false });

                btn.addEventListener('touchend', (evt) => {
                    evt.preventDefault();
                    // Reset visual feedback
                    evt.target.style.background = 'rgba(0, 0, 0, 0.9)';
                    evt.target.style.transform = 'scale(1)';
                }, { passive: false });

                // Prevent context menu on long press
                btn.addEventListener('contextmenu', (evt) => {
                    evt.preventDefault();
                });
            });
        }

        function handleDirectionalInput(direction) {
            if (etchActive) {
                // Etch-a-sketch mode
                const step = 1 / scale;
                switch (direction) {
                    case 'up': etchCursor.im += step; break;
                    case 'down': etchCursor.im -= step; break;
                    case 'left': etchCursor.re -= step; break;
                    case 'right': etchCursor.re += step; break;
                }

                // Ensure we have an etch stroke initialized
                let stroke = strokes[strokes.length - 1];
                if (!stroke || stroke.mode !== 'etch' || !Array.isArray(stroke.pts)) {
                    stroke = { canvas: 'domain', mode: 'etch', pts: [], imagePts: [], hue: Math.random() * 360 };
                    strokes.push(stroke);
                    if (strokes.length > MAX_STROKES) strokes.shift();
                }

                // Append new point to stroke in pixel coordinates
                stroke.pts.push(toCanvas(etchCursor, 'domain'));
                stroke.imagePts.push(toCanvas(userFn(etchCursor), 'codomain'));
                redrawAll();
            } else {
                // Panning mode
                const panStep = scale * 0.2; // Pan by 20% of a grid unit

                switch (direction) {
                    case 'up':
                        origin.domain.y += panStep;
                        origin.codomain.y += panStep;
                        break;
                    case 'down':
                        origin.domain.y -= panStep;
                        origin.codomain.y -= panStep;
                        break;
                    case 'left':
                        origin.domain.x += panStep;
                        origin.codomain.x += panStep;
                        break;
                    case 'right':
                        origin.domain.x -= panStep;
                        origin.codomain.x -= panStep;
                        break;
                }

                // Update all transformations when panning
                updateAllTransformations();
                redrawAll();
            }
        }

        function updateAllTransformations() {
            // Update stroke transformations (lines, circles, stars, spirals, etc.)
            updateStrokeTransformations();

            // Update text transformations
            if (texts.length > 0) {
                updateTextTransformations();
            }

            // Update image transformations
            images.forEach(img => {
                updateImageTransformation(img);
            });

            // Dots don't need updating as they are stored in mathematical coordinates
            // and canvas positions are calculated on each render
        }

        function updateStrokeTransformations() {
            // Recalculate image points for all strokes when function or view changes
            strokes.forEach(stroke => {
                if (stroke.pts && stroke.pts.length > 0) {
                    stroke.imagePts = stroke.pts.map(pt => {
                        const z = toComplex(pt.x, pt.y, stroke.canvas || 'domain');
                        const w = stroke.canvas === 'domain' ? userFn(z) : invFn(z);
                        return toCanvas(w, stroke.canvas === 'domain' ? 'codomain' : 'domain');
                    });
                }
            });
        }

        // Initialize directional controls
        setupDirectionalControls();

        // ===== HELP SYSTEM =====
        const helpModal = document.getElementById('helpModal');
        const helpText = document.getElementById('helpText');
        const closeHelp = document.getElementById('closeHelp');
        const helpBtn = document.getElementById('helpBtn');
        const hoverTooltip = document.getElementById('hoverTooltip');

        // Main comprehensive help content
        const mainHelpContent = `
            <h1>Complex Function Visualizer - User Guide</h1>
            
            <p>This tool visualizes complex function transformations by showing how shapes drawn on the input plane (left) are mapped to the output plane (right) under various mathematical functions.</p>

            <h2>How It Works</h2>
            <p>The <strong>left canvas (z plane)</strong> is where you draw input shapes. The <strong>right canvas (w plane)</strong> shows how these shapes transform under the selected complex function. Each point z = x + yi in the left plane maps to w = f(z) in the right plane.</p>

            <h2>Mathematical Functions</h2>
            
            <h3>z¬≤ (Squaring Function)</h3>
            <div class="math">f(z) = z¬≤ = (x + yi)¬≤ = (x¬≤ - y¬≤) + 2xyi</div>
            <p>Doubles angles and squares magnitudes. Circles centered at origin become cardioids (figure-8 shapes). Straight lines through origin become parabolas.</p>

            <h3>1/z (Reciprocal/Inversion)</h3>
            <div class="math">f(z) = 1/z = (x - yi)/(x¬≤ + y¬≤)</div>
            <p>Inverts with respect to the unit circle. Points inside the unit circle map outside, and vice versa. Circles through the origin become straight lines.</p>

            <h3>e^z (Exponential Function)</h3>
            <div class="math">f(z) = e^z = e^x(cos(y) + i¬∑sin(y))</div>
            <p>Maps horizontal lines to circles centered at origin. Vertical lines become rays from origin. Fundamental in complex analysis.</p>

            <h3>log(z) (Logarithm)</h3>
            <div class="math">f(z) = log(z) = log|z| + i¬∑arg(z)</div>
            <p>Inverse of exponential. Maps circles to horizontal lines and rays to vertical lines. Multi-valued function with branch cuts.</p>

            <h3>sin(z), cos(z) (Trigonometric Functions)</h3>
            <p>Complex extensions of real trigonometric functions. Create hyperbolic-type transformations with interesting symmetries.</p>

            <h3>‚àöz (Square Root)</h3>
            <div class="math">f(z) = ‚àöz = ‚àö|z| ¬∑ e^(i¬∑arg(z)/2)</div>
            <p>Halves angles and takes square root of magnitudes. Two-valued function - use "Continuous inverse" toggle for smooth visualization.</p>

            <h2>Drawing Tools</h2>

            <h3>Basic Tools</h3>
            <p><strong>Freehand:</strong> Draw arbitrary curves<br>
            <strong>Line:</strong> Straight line segments<br>
            <strong>Circle:</strong> Perfect circles<br>
            <strong>Dot:</strong> Individual points with coordinate labels</p>

            <h3>Parametric Shapes</h3>
            <p><strong>Polygon:</strong> Regular n-sided polygons<br>
            <strong>Star:</strong> Star polygons with n points<br>
            <strong>Spiral:</strong> Logarithmic spirals<br>
            <strong>Sine Wave:</strong> Sinusoidal curves</p>

            <h3>Advanced Tools</h3>
            <p><strong>Integer Grid:</strong> Shows coordinate transformation - essential for understanding function behavior<br>
            <strong>Text:</strong> Renders text that transforms mathematically. Drag corners to warp before transformation<br>
            <strong>Image:</strong> Import images via drag-drop or clipboard (Ctrl+V). Corner manipulation allows pre-transformation warping</p>

            <h3>Etch-a-Sketch Mode</h3>
            <p>Use WASD keys or arrow buttons for step-by-step drawing. Useful for precise path construction.</p>

            <h2>Controls</h2>

            <h3>Zoom</h3>
            <p>Critical feature: Different zoom levels represent different complex number ranges. The same physical shape at different zooms will transform completely differently, revealing function behavior at various scales.</p>

            <h3>Continuous Inverse</h3>
            <p>For multi-valued functions (‚àöz, z^(1/n)), this maintains branch continuity for smoother transformations.</p>

            <h3>Navigation</h3>
            <p>Arrow buttons or WASD keys pan the view (except in Etch mode where they control drawing).</p>

            <h2>Usage Examples</h2>

            <div class="example">
                <h3>Understanding Function Behavior</h3>
                <p>1. Select Integer Grid tool and z¬≤ function<br>
                2. Observe how the coordinate grid transforms<br>
                3. Notice angle doubling and the characteristic distortion</p>
            </div>

            <div class="example">
                <h3>Exploring Singularities</h3>
                <p>1. Draw circles of various sizes around origin with 1/z function<br>
                2. Observe how circles through origin become lines<br>
                3. See the behavior near z = 0 (the singularity)</p>
            </div>

            <div class="example">
                <h3>Scale-Dependent Behavior</h3>
                <p>1. Draw identical shapes at different zoom levels<br>
                2. Compare transformations - local vs global behavior becomes apparent<br>
                3. Essential for understanding analytic function properties</p>
            </div>

            <h2>Mathematical Concepts</h2>
            <p>This tool demonstrates conformal mapping, complex analysis, and geometric function theory. Each transformation preserves angles locally (except at singular points) and reveals the geometric nature of complex functions.</p>

            <p>Hover over the help button for context-sensitive information about the current function and tool combination.</p>
        `;

        // Event listeners for help system
        let lastTapTime = 0;
        const doubleTapDelay = 300; // milliseconds

        helpBtn.addEventListener('click', () => {
            helpText.innerHTML = mainHelpContent;
            helpModal.style.display = 'block';
        });

        // Double-tap detection for mobile
        helpBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTapTime;

            if (tapLength < doubleTapDelay && tapLength > 0) {
                // Double tap detected
                helpText.innerHTML = mainHelpContent;
                helpModal.style.display = 'block';
            } else {
                // Single tap - show context help briefly on mobile
                const contextHelp = getContextualHelpText();
                hoverTooltip.innerHTML = contextHelp;
                hoverTooltip.style.display = 'block';

                // Position tooltip above the button
                const rect = helpBtn.getBoundingClientRect();
                hoverTooltip.style.left = rect.left + 'px';
                hoverTooltip.style.bottom = (window.innerHeight - rect.top + 5) + 'px';

                // Auto-hide after 3 seconds on mobile
                setTimeout(() => {
                    hoverTooltip.style.display = 'none';
                }, 3000);
            }

            lastTapTime = currentTime;
        });

        // Hover tooltip for contextual help (desktop only)
        helpBtn.addEventListener('mouseenter', () => {
            const contextHelp = getContextualHelpText();
            hoverTooltip.innerHTML = contextHelp;
            hoverTooltip.style.display = 'block';

            // Position tooltip above the button
            const rect = helpBtn.getBoundingClientRect();
            hoverTooltip.style.left = rect.left + 'px';
            hoverTooltip.style.bottom = (window.innerHeight - rect.top + 5) + 'px';
        });

        helpBtn.addEventListener('mouseleave', () => {
            hoverTooltip.style.display = 'none';
        });

        function getContextualHelpText() {
            const fn = functionSelect.value;
            const tool = toolSelect.value;

            let functionDesc = '';
            let suggestion = '';

            switch (fn) {
                case 'z2':
                    functionDesc = "<strong>z¬≤ Function:</strong> Doubles angles, squares distances";
                    suggestion = "Try drawing circles at origin or lines through center to see squaring effect";
                    break;
                case 'z3':
                    functionDesc = "<strong>z¬≥ Function:</strong> Triples angles, cubes distances";
                    suggestion = "Draw shapes with rotational symmetry to see 3-fold multiplication";
                    break;
                case 'z4':
                    functionDesc = "<strong>z‚Å¥ Function:</strong> Quadruples angles, fourth power distances";
                    suggestion = "Notice 4-fold symmetry in transformations";
                    break;
                case 'inv':
                    functionDesc = "<strong>1/z Inversion:</strong> Swaps inside/outside unit circle";
                    suggestion = "Draw circles through origin (become lines) or around origin";
                    break;
                case 'exp':
                    functionDesc = "<strong>e^z Exponential:</strong> Horizontal lines ‚Üí circles, vertical ‚Üí rays";
                    suggestion = "Try grid tool to see how rectangular coordinates transform";
                    break;
                case 'log':
                    functionDesc = "<strong>log(z) Logarithm:</strong> Circles ‚Üí horizontal lines, rays ‚Üí vertical";
                    suggestion = "Inverse of exponential - try concentric circles or radial lines";
                    break;
                case 'sin':
                    functionDesc = "<strong>sin(z) Sine:</strong> Complex sine with hyperbolic behavior";
                    suggestion = "Draw horizontal or vertical lines to see periodic/hyperbolic effects";
                    break;
                case 'cos':
                    functionDesc = "<strong>cos(z) Cosine:</strong> Complex cosine function";
                    suggestion = "Similar to sine with 90¬∞ phase shift";
                    break;
                case 'sqrt':
                    functionDesc = "<strong>‚àöz Square Root:</strong> Halves angles, square root distances";
                    suggestion = "Enable continuous inverse for smooth branch behavior";
                    break;
                case 'zbar':
                    functionDesc = "<strong>zÃÑ Conjugate:</strong> Reflects across real axis";
                    suggestion = "Notice how shapes flip vertically";
                    break;
                case 'mobius':
                    functionDesc = "<strong>M√∂bius Transform:</strong> (z-1)/(z+1) maps circles/lines";
                    suggestion = "Draw circles to see circle-preserving property";
                    break;
                case 'quadratic':
                    functionDesc = "<strong>z¬≤+z Quadratic:</strong> Combination transformation";
                    suggestion = "Observe asymmetric distortion from linear + quadratic terms";
                    break;
                default:
                    functionDesc = `<strong>${fn} Function:</strong> Mathematical transformation`;
                    suggestion = "Experiment with different shapes to understand behavior";
            }

            let toolInfo = '';
            switch (tool) {
                case 'chessboard':
                    toolInfo = "<strong>Grid Tool:</strong> Shows coordinate transformation";
                    break;
                case 'image':
                    toolInfo = "<strong>Image Tool:</strong> Paste (Ctrl+V) or drag images";
                    break;
                case 'text':
                    toolInfo = "<strong>Text Tool:</strong> Add transformable text";
                    break;
                case 'etch':
                    toolInfo = "<strong>Etch Tool:</strong> Use WASD/arrows to draw";
                    break;
                case 'circle':
                    toolInfo = "<strong>Circle Tool:</strong> Perfect circles";
                    break;
                case 'line':
                    toolInfo = "<strong>Line Tool:</strong> Straight lines";
                    break;
                case 'dot':
                    toolInfo = "<strong>Dot Tool:</strong> Points with coordinates";
                    break;
                default:
                    toolInfo = `<strong>${tool.charAt(0).toUpperCase() + tool.slice(1)} Tool:</strong> Drawing mode`;
            }

            return `${functionDesc}<br>${toolInfo}<br><em>Tip:</em> ${suggestion}<br><br><strong>Click for full help</strong>`;
        }

        closeHelp.addEventListener('click', () => {
            helpModal.style.display = 'none';
        });

        helpModal.addEventListener('click', (evt) => {
            if (evt.target === helpModal) {
                helpModal.style.display = 'none';
            }
        });

        // Export functionality
        const exportBtn = document.getElementById('exportBtn');

        exportBtn.addEventListener('click', () => {
            // Export both canvases using current theme
            exportCanvas('domain');
            setTimeout(() => exportCanvas('codomain'), 100); // Small delay to avoid conflicts
        });

        // Export function that uses current theme
        function exportCanvas(canvasKey) {
            const canvas = canvases[canvasKey];
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');

            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;

            // Fill background with current theme color
            tempCtx.fillStyle = isDarkMode ? '#222222' : '#ffffff';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

            // Draw the original canvas content
            tempCtx.drawImage(canvas, 0, 0);

            // Create download link
            const link = document.createElement('a');
            const themeName = isDarkMode ? 'dark' : 'light';
            link.download = `complex-visualizer-${canvasKey}-${themeName}-${new Date().getTime()}.png`;
            link.href = tempCanvas.toDataURL('image/png');
            link.click();
        }
    </script>
    <!-- Thank You Icon -->
    <div id="thankYouIcon"
        style="position:fixed; bottom:10px; right:10px; font-size:24px; cursor:pointer; color:red; z-index:100;">‚ù§Ô∏è
    </div>
    <div id="thankYouPopup"
        style="display:none; position:fixed; bottom:40px; right:10px; background:rgba(0,0,0,0.8); color:#fff; padding:10px; border-radius:6px; max-width:220px; font-size:12px; z-index:100;">
        Thank you for using Real Complex, I hope you find it useful. If you have any questions or bugs or love it enough
        to support then contact me / paypal <a href="mailto:sickfiction@gmail.com"
            style="color:#fff; text-decoration:underline;">sickfiction@gmail.com</a> Have a great day. <br />‚Äî James
    </div>
    <script>
        document.getElementById('thankYouIcon').addEventListener('click', () => {
            const popup = document.getElementById('thankYouPopup');
            popup.style.display = popup.style.display === 'none' ? 'block' : 'none';
        });

        // Final initialization
        resize();
        redrawAll();
    </script>
</body>

</html>
